From 6b71648f376fc96ff4c1eaa3efd87cab23f91065 Mon Sep 17 00:00:00 2001
From: XiNGRZ <chenxingyu92@gmail.com>
Date: Tue, 25 Jul 2017 18:26:25 -0700
Subject: [PATCH] [SQUASHED] Reconfigure gestures implementation

---
 drivers/input/misc/tri_state_key.c                 |  464 ++-
 drivers/input/touchscreen/synaptics_driver_s3320.c | 3634 +++++++++++---------
 2 files changed, 2178 insertions(+), 1920 deletions(-)

diff --git a/drivers/input/misc/tri_state_key.c b/drivers/input/misc/tri_state_key.c
index b52d4e5..faad1e0 100644
--- a/drivers/input/misc/tri_state_key.c
+++ b/drivers/input/misc/tri_state_key.c
@@ -12,6 +12,7 @@
 #include <linux/input.h>
 #include <linux/ioport.h>
 #include <linux/platform_device.h>
+#include <linux/proc_fs.h>
 #include <linux/gpio.h>
 #include <linux/gpio_keys.h>
 #include <linux/of_platform.h>
@@ -26,328 +27,276 @@
 
 #include <linux/timer.h>
 
-#define DRV_NAME	"tri-state-key"
+#define DRV_NAME "tri-state-key"
 
 /*
-	        	KEY1(GPIO1)	KEY2(GPIO92)
-pin1 connect to pin4	0	            1         | MUTE
-pin2 connect to pin5	1	            1         | Do Not Disturb
-pin4 connect to pin3	1	            0         | Normal
+ * Original tri-state modes designed by OnePlus
+ */
 
-*/
-typedef enum
-{
+typedef enum {
 	MODE_UNKNOWN,
 	MODE_MUTE,
 	MODE_DO_NOT_DISTURB,
 	MODE_NORMAL,
-	MODE_MAX_NUM
 } tri_mode_t;
 
-//static struct platform_device *tri_state_key_dev;
+/*
+ * Target key codes sending to OPPO's Keyhandler
+ * see KeyHandler.java in device/oppo/common/keyhandler
+ */
 
+#define KEY_MODE_TOTAL_SILENCE  600
+#define KEY_MODE_ALARMS_ONLY    601
+#define KEY_MODE_PRIORITY_ONLY  602
+#define KEY_MODE_NONE           603
 
-struct switch_dev_data
-{
-	//tri_mode_t last_type;
-	//tri_mode_t mode_type;
-	//int switch_enable;
-	int irq_key3;
-	int irq_key2;
+static int current_mode = MODE_UNKNOWN;
+
+/*
+ * Default mapping between OP's sti-state switch and OPPO's key codes
+ * see Constants.java in device/oppo/common/configpanel
+ */
+
+static int keyCode_slider_top = KEY_MODE_ALARMS_ONLY;
+static int keyCode_slider_middle = KEY_MODE_PRIORITY_ONLY;
+static int keyCode_slider_bottom = KEY_MODE_NONE;
+
+struct switch_dev_data {
 	int irq_key1;
-	int key1_gpio;//key1 gpio34
-	int key2_gpio;//key2 gpio77
-	int key3_gpio;
+	int irq_key2;
+	int irq_key3;
 
-	struct regulator *vdd_io;
-	//bool power_enabled;
+	int key1_gpio; // Mute
+	int key2_gpio; // Do Not Disturb
+	int key3_gpio; // Normal
 
 	struct work_struct work;
-	struct switch_dev sdev;
+
 	struct device *dev;
-	//struct input_dev *input;
+	struct input_dev *input;
+	struct switch_dev sdev;
 
 	struct timer_list s_timer;
-	struct pinctrl * key_pinctrl;
-	struct pinctrl_state * set_state;
 
+	struct pinctrl *key_pinctrl;
+	struct pinctrl_state *set_state;
 };
 
 static struct switch_dev_data *switch_data;
+
 static DEFINE_MUTEX(sem);
-//#if 0
-static int set_gpio_by_pinctrl(void)
+
+static void send_input(int keyCode)
 {
-	printk(KERN_ERR "tristate_key set_gpio_by_pinctrl. \n");
-	return pinctrl_select_state(switch_data->key_pinctrl, switch_data->set_state);
+	input_report_key(switch_data->input, keyCode, 1);
+	input_sync(switch_data->input);
+	input_report_key(switch_data->input, keyCode, 0);
+	input_sync(switch_data->input);
 }
-//#endif
+
 static void switch_dev_work(struct work_struct *work)
 {
-
-	int key1,key2,key3;
-	//pr_err("%s  gpio_get_value(%d)=%d\n",__func__,switch_data->key1_gpio,gpio_get_value(switch_data->key1_gpio));
-	//pr_err("%s  gpio_get_value(%d)=%d\n",__func__,switch_data->key2_gpio,gpio_get_value(switch_data->key2_gpio));
-	//pr_err("%s  gpio_get_value(%d)=%d\n",__func__,switch_data->key3_gpio,gpio_get_value(switch_data->key3_gpio));
-	//pr_err("entering tristate:switch_dev_work\n");
+	int key1, key2, key3;
+	int mode = MODE_UNKNOWN;
+	int keyCode;
 
 	mutex_lock(&sem);
-	key1=gpio_get_value(switch_data->key1_gpio);
-	key2=gpio_get_value(switch_data->key2_gpio);
-	key3=gpio_get_value(switch_data->key3_gpio);
-	//pr_err("tristate %s,key1=%d,key2=%d,key3=%d\n",__func__,key1,key2,key3);
-	if(((key1==0)&&(key2==1)&&(key3==1))||((key1==1)&&(key2==0)&&(key3==1))||((key1==1)&&(key2==1)&&(key3==0)))
-	{
-		//gpio_set_value(switch_data->key3_gpio,0);
-		printk("tristate_key set_gpio_by_pinctrl. \n");
-		if(!key2)
-		{
-			switch_set_state(&switch_data->sdev, MODE_DO_NOT_DISTURB);
-			//pr_err("%s MODE_DO_NOT_DISTURB\n",__func__);
-		}
-
-		if(!key3)
-		{
-			switch_set_state(&switch_data->sdev, MODE_NORMAL);
-			//pr_err("%s MODE_NORMAL\n",__func__);
-
-		}
-
-		if(!key1)
-		{
-			switch_set_state(&switch_data->sdev, MODE_MUTE);
-			//pr_err("%s MODE_MUTE\n",__func__);
-
-		}
-
-		printk(KERN_ERR "%s ,tristatekey set to state(%d) \n",__func__,switch_data->sdev.state);
+
+	key1 = gpio_get_value(switch_data->key1_gpio);
+	key2 = gpio_get_value(switch_data->key2_gpio);
+	key3 = gpio_get_value(switch_data->key3_gpio);
+
+	if (key1 == 0) {
+		mode = MODE_MUTE;
+		keyCode = keyCode_slider_top;
+	} else if (key2 == 0) {
+		mode = MODE_DO_NOT_DISTURB;
+		keyCode = keyCode_slider_middle;
+	} else if (key3 == 0) {
+		mode = MODE_NORMAL;
+		keyCode = keyCode_slider_bottom;
+	}
+
+	if (current_mode != mode && mode != MODE_UNKNOWN) {
+		current_mode = mode;
+		switch_set_state(&switch_data->sdev, current_mode);
+		send_input(keyCode);
+		printk(DRV_NAME " changed to mode: %d\n", switch_data->sdev.state);
 	}
+
 	mutex_unlock(&sem);
 }
+
 irqreturn_t switch_dev_interrupt(int irq, void *_dev)
 {
-//printk("%s\n",__func__);
 	schedule_work(&switch_data->work);
-
 	return IRQ_HANDLED;
 }
 
 static void timer_handle(unsigned long arg)
 {
-	//mod_timer(&s_timer, jiffies + HZ);
-	//  if(set_gpio_by_pinctrl() < 0)
-	//      printk(KERN_ERR "tristate_key set_gpio_by_pinctrl FAILD!!!. \n");
 	schedule_work(&switch_data->work);
-	//del_timer(&switch_data->s_timer);
-
-	//printk(KERN_ERR "tristate_key set gpio77 timer. \n");
 }
 
-/* //no need cause switch_class.c state_show()
-static ssize_t switch_dev_print_state(struct switch_dev *sdev, char *buf)
-{
-	tri_mode_t state;
-		state = switch_data->mode_type;
-
-	if (state)
-		return sprintf(buf, "%d\n", state);
-	return -1;
-}
-*/
-
 #ifdef CONFIG_OF
 static int switch_dev_get_devtree_pdata(struct device *dev)
 {
 	struct device_node *node;
 
 	node = dev->of_node;
-	if (!node){
-		//printk("<0>""no node was found!!!!,%s\n",__func__);
+	if (!node)
 		return -EINVAL;
-	}
-	switch_data->key3_gpio= of_get_named_gpio(node, "tristate,gpio_key3", 0);
-	if ((!gpio_is_valid(switch_data->key3_gpio)))
+
+	switch_data->key1_gpio = of_get_named_gpio(node, "tristate,gpio_key1", 0);
+	if (!gpio_is_valid(switch_data->key1_gpio))
 		return -EINVAL;
-	pr_err("switch_data->key3_gpio=%d \n", switch_data->key3_gpio);
 
-	switch_data->key2_gpio= of_get_named_gpio(node, "tristate,gpio_key2", 0);
-	if ((!gpio_is_valid(switch_data->key2_gpio)))
+	switch_data->key2_gpio = of_get_named_gpio(node, "tristate,gpio_key2", 0);
+	if (!gpio_is_valid(switch_data->key2_gpio))
 		return -EINVAL;
-	pr_err("switch_data->key2_gpio=%d \n", switch_data->key2_gpio);
-//printk("%s, key2 gpio:%d \n", __func__, switch_data->key2_gpio);
 
-	switch_data->key1_gpio= of_get_named_gpio(node, "tristate,gpio_key1", 0);
-	if ((!gpio_is_valid(switch_data->key1_gpio)))
+	switch_data->key3_gpio = of_get_named_gpio(node, "tristate,gpio_key3", 0);
+	if (!gpio_is_valid(switch_data->key3_gpio))
 		return -EINVAL;
-	pr_err("switch_data->key1_gpio=%d \n", switch_data->key1_gpio);
-//printk("%s, key1 gpio:%d \n", __func__, switch_data->key1_gpio);
+
 	return 0;
 }
-
 #else
-
 static inline int
 switch_dev_get_devtree_pdata(struct device *dev)
 {
-	printk("<0>""%s inline function",__func__);
 	return 0;
 }
 #endif
 
+#define KEYCODE_FOPS(WHICH)\
+	static int keyCode_##WHICH##_show(struct seq_file *seq, void *offset)\
+	{\
+		seq_printf(seq, "%d\n", keyCode_slider_##WHICH);\
+		return 0;\
+	}\
+	static ssize_t keyCode_##WHICH##_write(struct file *file,\
+			const char __user *page, size_t t, loff_t *lo)\
+	{\
+		int data;\
+		char buf[10];\
+		if (copy_from_user(buf, page, t)) {\
+			dev_err(switch_data->dev, "read proc input error.\n");\
+			return t;\
+		}\
+		if (sscanf(buf, "%d", &data) != 1)\
+			return t;\
+		if (data < 600 || data > 603)\
+			return t;\
+		keyCode_slider_##WHICH = data;\
+		if (current_mode == 1)\
+			send_input(keyCode_slider_##WHICH);\
+		return t;\
+	}\
+	static int keyCode_##WHICH##_open(struct inode *inode, struct file *file)\
+	{\
+		return single_open(file, keyCode_##WHICH##_show, inode->i_private);\
+	}\
+	const struct file_operations proc_keyCode_##WHICH = {\
+		.owner		= THIS_MODULE,\
+		.open		= keyCode_##WHICH##_open,\
+		.read		= seq_read,\
+		.write		= keyCode_##WHICH##_write,\
+		.llseek 	= seq_lseek,\
+		.release	= single_release,\
+	};
+
+KEYCODE_FOPS(top);
+KEYCODE_FOPS(middle);
+KEYCODE_FOPS(bottom);
+
+#define REGISTER_IRQ_FOR(KEY)\
+	switch_data->irq_##KEY = gpio_to_irq(switch_data->KEY##_gpio);\
+	if (switch_data->irq_##KEY <= 0) {\
+		dev_err(dev, "%s: irq number is not specified, irq #= %d, int pin=%d\n",\
+			__func__, switch_data->irq_##KEY, switch_data->KEY##_gpio);\
+		goto err_detect_irq_num_failed;\
+	} else {\
+		error = gpio_request(switch_data->KEY##_gpio, "tristate_" #KEY "-int");\
+		if (error < 0) {\
+			dev_err(dev, "%s: gpio_request, err=%d\n", __func__, error);\
+			goto err_request_gpio;\
+		}\
+		error = gpio_direction_input(switch_data->KEY##_gpio);\
+		if (error < 0) {\
+			dev_err(dev, "%s: gpio_direction_input, err=%d\n", __func__, error);\
+			goto err_set_gpio_input;\
+		}\
+		error = request_irq(switch_data->irq_##KEY, switch_dev_interrupt,\
+			IRQF_TRIGGER_FALLING, "tristate_" #KEY, switch_data);\
+		if (error) {\
+			dev_err(dev, "%s: request_irq, err=%d\n", __func__, error);\
+			switch_data->irq_##KEY = -EINVAL;\
+			goto err_request_irq;\
+		}\
+	}
+
 static int tristate_dev_probe(struct platform_device *pdev)
 {
-	struct device *dev;
-	int error;
+	struct device *dev = &pdev->dev;
+	struct proc_dir_entry *procdir;
+	int error = 0;
 
-	dev= &pdev->dev;
-	error = 0;
+	switch_data = kzalloc(sizeof(struct switch_dev_data), GFP_KERNEL);
+	switch_data->dev = dev;
 
+	switch_data->input = input_allocate_device();
 
-	//pr_err("tristate_key set_gpio_by_pinctrl. \n");
-	//void __iomem *cfg_reg;
-	//void __iomem *cfg_reg;
+	// init input device
 
+	switch_data->input->name = DRV_NAME;
+	switch_data->input->dev.parent = &pdev->dev;
 
-	switch_data = kzalloc(sizeof(struct switch_dev_data), GFP_KERNEL);
-	switch_data->dev = dev;
-	//pr_err("%s  init platform_device.probe\n",__func__);
+	set_bit(EV_KEY, switch_data->input->evbit);
+
+	set_bit(KEY_MODE_TOTAL_SILENCE, switch_data->input->keybit);
+	set_bit(KEY_MODE_ALARMS_ONLY, switch_data->input->keybit);
+	set_bit(KEY_MODE_PRIORITY_ONLY, switch_data->input->keybit);
+	set_bit(KEY_MODE_NONE, switch_data->input->keybit);
+
+	input_set_drvdata(switch_data->input, switch_data);
+
+	error = input_register_device(switch_data->input);
+	if (error) {
+		dev_err(dev, "Failed to register input device\n");
+		goto err_input_device_register;
+	}
+
+	// init pinctrl
 
-//#if 0
 	switch_data->key_pinctrl = devm_pinctrl_get(switch_data->dev);
-	if (IS_ERR_OR_NULL(switch_data->key_pinctrl))
-	{
-		dev_err(switch_data->dev, "Failed to get pinctrl \n");
+	if (IS_ERR_OR_NULL(switch_data->key_pinctrl)) {
+		dev_err(dev, "Failed to get pinctrl\n");
 		goto err_switch_dev_register;
 	}
-	switch_data->set_state =pinctrl_lookup_state(switch_data->key_pinctrl,"pmx_tri_state_key_active");
-	if (IS_ERR_OR_NULL(switch_data->set_state))
-	{
-		dev_err(switch_data->dev, "Failed to lookup_state \n");
+
+	switch_data->set_state = pinctrl_lookup_state(switch_data->key_pinctrl,
+		"pmx_tri_state_key_active");
+	if (IS_ERR_OR_NULL(switch_data->set_state)) {
+		dev_err(dev, "Failed to lookup_state\n");
 		goto err_switch_dev_register;
 	}
 
-	set_gpio_by_pinctrl();
-//#endif
-	//switch_data->last_type = MODE_UNKNOWN;
+	pinctrl_select_state(switch_data->key_pinctrl, switch_data->set_state);
+
+	// parse gpios from dt
 
-	//tristate_supply_init();
 	error = switch_dev_get_devtree_pdata(dev);
-	if (error)
-	{
+	if (error) {
 		dev_err(dev, "parse device tree fail!!!\n");
 		goto err_switch_dev_register;
 	}
 
-	//config irq gpio and request irq
-	switch_data->irq_key1 = gpio_to_irq(switch_data->key1_gpio);
-	if (switch_data->irq_key1 <= 0)
-	{
-		printk("%s, irq number is not specified, irq #= %d, int pin=%d\n\n", __func__, switch_data->irq_key1, switch_data->key1_gpio);
-		goto err_detect_irq_num_failed;
-	}
-	else
-	{
-		error = gpio_request(switch_data->key1_gpio,"tristate_key1-int");
-		if(error < 0)
-		{
-			printk(KERN_ERR "%s: gpio_request, err=%d", __func__, error);
-			goto err_request_gpio;
-		}
-		error = gpio_direction_input(switch_data->key1_gpio);
-		if(error < 0)
-		{
-			printk(KERN_ERR "%s: gpio_direction_input, err=%d", __func__, error);
-			goto err_set_gpio_input;
-		}
-
-		error = request_irq(switch_data->irq_key1, switch_dev_interrupt,
-		                    IRQF_TRIGGER_FALLING, "tristate_key1", switch_data);
-
-		if (error)
-		{
-			dev_err(dev,
-			        "request_irq %i failed.\n",
-			        switch_data->irq_key1);
-
-			switch_data->irq_key1 = -EINVAL;
-			goto err_request_irq;
-		}
-	}
-	//config irq gpio and request irq
-	switch_data->irq_key2 = gpio_to_irq(switch_data->key2_gpio);
-	if (switch_data->irq_key2 <= 0)
-	{
-		printk("%s, irq number is not specified, irq #= %d, int pin=%d\n\n", __func__, switch_data->irq_key2, switch_data->key2_gpio);
-		goto err_detect_irq_num_failed;
-	}
-	else
-	{
-		error = gpio_request(switch_data->key2_gpio,"tristate_key2-int");
-		if(error < 0)
-		{
-			printk(KERN_ERR "%s: gpio_request, err=%d", __func__, error);
-			goto err_request_gpio;
-		}
-		error = gpio_direction_input(switch_data->key2_gpio);
-		if(error < 0)
-		{
-			printk(KERN_ERR "%s: gpio_direction_input, err=%d", __func__, error);
-			goto err_set_gpio_input;
-		}
-
-		error = request_irq(switch_data->irq_key2, switch_dev_interrupt,
-		                    IRQF_TRIGGER_FALLING, "tristate_key2", switch_data);
-
-		if (error)
-		{
-			dev_err(dev,
-			        "request_irq %i failed.\n",
-			        switch_data->irq_key2);
-
-			switch_data->irq_key2 = -EINVAL;
-			goto err_request_irq;
-		}
-
-	}
-
-	switch_data->irq_key3 = gpio_to_irq(switch_data->key3_gpio);
-	if (switch_data->irq_key3 <= 0)
-	{
-		printk("%s, irq number is not specified, irq #= %d, int pin=%d\n\n", __func__, \
-		       switch_data->irq_key3, switch_data->key3_gpio);
-		goto err_detect_irq_num_failed;
-	}
-	else
-	{
-		error = gpio_request(switch_data->key3_gpio,"tristate_key3-int");
-		if(error < 0)
-		{
-			printk(KERN_ERR "%s: gpio_request, err=%d", __func__, error);
-			goto err_request_gpio;
-		}
-		error = gpio_direction_input(switch_data->key3_gpio);
-		if(error < 0)
-		{
-			printk(KERN_ERR "%s: gpio_direction_input, err=%d", __func__, error);
-			goto err_set_gpio_input;
-		}
-
-
-		error = request_irq(switch_data->irq_key3, switch_dev_interrupt,
-		                    IRQF_TRIGGER_FALLING, "tristate_key3", switch_data);
-
-		if (error)
-		{
-			dev_err(dev,
-			        "request_irq %i failed.\n",
-			        switch_data->irq_key3);
-
-			switch_data->irq_key3 = -EINVAL;
-			goto err_request_irq;
-		}
-
-	}
+	// irqs and work, timer stuffs
 
+	REGISTER_IRQ_FOR(key1);
+	REGISTER_IRQ_FOR(key2);
+	REGISTER_IRQ_FOR(key3);
 
 	INIT_WORK(&switch_data->work, switch_dev_work);
 
@@ -361,65 +310,76 @@ static int tristate_dev_probe(struct platform_device *pdev)
 	enable_irq_wake(switch_data->irq_key2);
 	enable_irq_wake(switch_data->irq_key3);
 
+	// init switch device
 
 	switch_data->sdev.name = DRV_NAME;
 	error = switch_dev_register(&switch_data->sdev);
-	if (error < 0)
+	if (error < 0) {
+		dev_err(dev, "Failed to register switch dev\n");
 		goto err_request_gpio;
-	//set_gpio_by_pinctrl();
-	//report the first switch
-	//switch_dev_work(&switch_data->work);
-	return 0;
+	}
 
+	// init proc fs
+
+	procdir = proc_mkdir("tri-state-key", NULL);
+
+	proc_create_data("keyCode_top", 0666, procdir,
+		&proc_keyCode_top, NULL);
+
+	proc_create_data("keyCode_middle", 0666, procdir,
+		&proc_keyCode_middle, NULL);
+
+	proc_create_data("keyCode_bottom", 0666, procdir,
+		&proc_keyCode_bottom, NULL);
+
+	return 0;
 
 err_request_gpio:
 	switch_dev_unregister(&switch_data->sdev);
 err_request_irq:
 err_detect_irq_num_failed:
 err_set_gpio_input:
-	gpio_free(switch_data->key2_gpio);
 	gpio_free(switch_data->key1_gpio);
+	gpio_free(switch_data->key2_gpio);
 	gpio_free(switch_data->key3_gpio);
 err_switch_dev_register:
 	kfree(switch_data);
-        printk("%s, meet_error\n\n", __func__);
-
+err_input_device_register:
+	input_unregister_device(switch_data->input);
+	input_free_device(switch_data->input);
+	dev_err(dev, "%s error: %d\n", __func__, error);
 	return error;
 }
 
 static int tristate_dev_remove(struct platform_device *pdev)
 {
-	printk("%s\n",__func__);
 	cancel_work_sync(&switch_data->work);
 	gpio_free(switch_data->key1_gpio);
 	gpio_free(switch_data->key2_gpio);
 	gpio_free(switch_data->key3_gpio);
 	switch_dev_unregister(&switch_data->sdev);
 	kfree(switch_data);
-
 	return 0;
 }
 
 #ifdef CONFIG_OF
-static struct of_device_id tristate_dev_of_match[] =
-{
+static struct of_device_id tristate_dev_of_match[] = {
 	{ .compatible = "oneplus,tri-state-key", },
 	{ },
 };
 MODULE_DEVICE_TABLE(of, tristate_dev_of_match);
 #endif
 
-static struct platform_driver tristate_dev_driver =
-{
+static struct platform_driver tristate_dev_driver = {
 	.probe	= tristate_dev_probe,
 	.remove	= tristate_dev_remove,
 	.driver	= {
 		.name	= DRV_NAME,
 		.owner	= THIS_MODULE,
-		.of_match_table = tristate_dev_of_match,
+		.of_match_table = of_match_ptr(tristate_dev_of_match),
 	},
 };
 module_platform_driver(tristate_dev_driver);
+
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("switch Profiles by this triple key driver");
-
diff --git a/drivers/input/touchscreen/synaptics_driver_s3320.c b/drivers/input/touchscreen/synaptics_driver_s3320.c
index 2505f79..45c4993 100755
--- a/drivers/input/touchscreen/synaptics_driver_s3320.c
+++ b/drivers/input/touchscreen/synaptics_driver_s3320.c
@@ -118,36 +118,7 @@ struct test_header {
 #define SWIPE_DETECT    0x07
 #define DTAP_DETECT     0x03
 
-
-#define UnkownGestrue       0
-#define DouTap              1   // double tap
-#define UpVee               2   // V
-#define DownVee             3   // ^
-#define LeftVee             4   // >
-#define RightVee            5   // <
-#define Circle              6   // O
-#define DouSwip             7   // ||
-#define Left2RightSwip      8   // -->
-#define Right2LeftSwip      9   // <--
-#define Up2DownSwip         10  // |v
-#define Down2UpSwip         11  // |^
-#define Mgestrue            12  // M
-#define Wgestrue            13  // W
-#define Sgestrue            14  // S
-
-// carlo@oneplus.net 2015-05-25, begin.
-#define KEY_GESTURE_W          	246 //w
-#define KEY_GESTURE_M      		247 //m
-#define KEY_GESTURE_S			248 //s
-#define KEY_DOUBLE_TAP          249 // double tap to wake
-#define KEY_GESTURE_CIRCLE      250 // draw circle to lunch camera
-#define KEY_GESTURE_TWO_SWIPE	251 // swipe two finger vertically to play/pause
-#define KEY_GESTURE_V           252 // draw v to toggle flashlight
-#define KEY_GESTURE_LEFT_V      253 // draw left arrow for previous track
-#define KEY_GESTURE_RIGHT_V     254 // draw right arrow for next track
-// carlo@oneplus.net 2015-05-25, end.
-
-//ruanbanmao@BSP add for tp gesture 2015-05-06, begin
+// Gesture bit mask
 #define BIT0 (0x1 << 0)
 #define BIT1 (0x1 << 1)
 #define BIT2 (0x1 << 2)
@@ -156,27 +127,57 @@ struct test_header {
 #define BIT5 (0x1 << 5)
 #define BIT6 (0x1 << 6)
 #define BIT7 (0x1 << 7)
-
-int LeftVee_gesture = 0; //">"
-int RightVee_gesture = 0; //"<"
-int DouSwip_gesture = 0; // "||"
-int Circle_gesture = 0; // "O"
-int UpVee_gesture = 0; //"V"
-int DownVee_gesture = 0; //"^"
-int DouTap_gesture = 0; //"double tap"
-
-int Left2RightSwip_gesture=0;//"(-->)"
-int Right2LeftSwip_gesture=0;//"(<--)"
-int Up2DownSwip_gesture =0;//"up to down |"
-int Down2UpSwip_gesture =0;//"down to up |"
-
-int Wgestrue_gesture =0;//"(W)"
-int Mgestrue_gesture =0;//"(M)"
-int Sgestrue_gesture =0;//"(S)"
-static int gesture_switch = 0;
-//ruanbanmao@BSP add for tp gesture 2015-05-06, end
+#define BIT8 (0x1 << 8)
+#define BIT9 (0x1 << 9)
+#define BITA (0x1 << 10)
+#define BITB (0x1 << 11)
+#define BITC (0x1 << 12)
+#define BITD (0x1 << 13)
+#define BITE (0x1 << 14)
+#define BITF (0x1 << 15)
+
+// Gesture flags
+#define GESTURE_NONE            BIT0
+#define GESTURE_DOUBLE_TAP      BIT1 // double tap
+#define GESTURE_DOWN_ARROW      BIT2 // V
+#define GESTURE_UP_ARROW        BIT3 // ^
+#define GESTURE_RIGHT_ARROW     BIT4 // >
+#define GESTURE_LEFT_ARROW      BIT5 // <
+#define GESTURE_CIRCLE          BIT6 // O
+#define GESTURE_DOUBLE_SWIPE    BIT7 // ||
+#define GESTURE_RIGHT_SWIPE     BIT8 // ->
+#define GESTURE_LEFT_SWIPE      BIT9 // <-
+#define GESTURE_DOWN_SWIPE      BITA // |v
+#define GESTURE_UP_SWIPE        BITB // |^
+#define GESTURE_M               BITC // M
+#define GESTURE_W               BITD // W
+#define GESTURE_S               BITE // S
+
+// Gesture key codes
+#define KEY_GESTURE_W               246 // W
+#define KEY_GESTURE_M               247 // M
+#define KEY_GESTURE_S               248 // S
+#define KEY_DOUBLE_TAP              KEY_WAKEUP // double tap to wake
+#define KEY_GESTURE_CIRCLE          250 // draw circle to lunch camera
+#define KEY_GESTURE_TWO_SWIPE       251 // swipe two finger vertically to play/pause
+#define KEY_GESTURE_UP_ARROW        255 // draw up arrow to toggle flashlight
+#define KEY_GESTURE_LEFT_ARROW      253 // draw left arrow for previous track
+#define KEY_GESTURE_RIGHT_ARROW     254 // draw right arrow for next track
+#define KEY_GESTURE_DOWN_ARROW      252 // draw down arrow to toggle flashlight
+#define KEY_GESTURE_SWIPE_RIGHT     KEY_F5
+#define KEY_GESTURE_SWIPE_LEFT      KEY_F6
+#define KEY_GESTURE_SWIPE_DOWN      KEY_F7
+#define KEY_GESTURE_SWIPE_UP        KEY_F8
 #endif
 
+// Button key mask
+#define BUTTON_LEFT     (0x1 << 1)
+#define BUTTON_RIGHT    (0x1 << 0)
+
+// Button key codes
+#define KEY_BUTTON_LEFT     KEY_BACK
+#define KEY_BUTTON_RIGHT    KEY_APPSELECT
+
 /*********************for Debug LOG switch*******************/
 #define TPD_ERR(a, arg...)  pr_err(TPD_DEVICE ": " a, ##arg)
 #define TPDTM_DMESG(a, arg...)  printk(TPD_DEVICE ": " a, ##arg)
@@ -202,13 +203,13 @@ static int TX_NUM;
 static int RX_NUM;
 static int report_key_point_y = 0;
 static int force_update = 0;
-static int LCD_WIDTH ;
-static int LCD_HEIGHT ;
+static int LCD_WIDTH;
+static int LCD_HEIGHT;
 static int get_tp_base = 0;
 #define ENABLE_TPEDGE_LIMIT
 #ifdef ENABLE_TPEDGE_LIMIT
 static int F51_CUSTOM_CTRL74;
-static int limit_enable=1;
+static int limit_enable = 1;
 static void synaptics_tpedge_limitfunc(void);
 #endif
 //static int ch_getbase_status = 0;
@@ -217,15 +218,10 @@ static void synaptics_tpedge_limitfunc(void);
 #ifdef SUPPORT_TP_SLEEP_MODE
 static int sleep_enable;
 #endif
-#ifdef SUPPORT_TP_TOUCHKEY
-static int key_switch = 0;
-static bool key_back_disable=false,key_appselect_disable=false;
-#endif
 static struct synaptics_ts_data *ts_g = NULL;
 static struct workqueue_struct *synaptics_wq = NULL;
 static struct workqueue_struct *synaptics_report = NULL;
 static struct workqueue_struct *get_base_report = NULL;
-static struct proc_dir_entry *prEntry_tp = NULL;
 
 
 #ifdef SUPPORT_GESTURE
@@ -306,7 +302,7 @@ static int F34_FLASH_CTRL00;
 static int F51_CUSTOM_CTRL00;
 static int F51_CUSTOM_DATA04;
 static int F51_CUSTOM_DATA11;
-static int version_is_s3508=0;
+static int version_is_s3508 = 0;
 #if TP_TEST_ENABLE
 static int F54_ANALOG_QUERY_BASE;//0x73
 static int F54_ANALOG_COMMAND_BASE;//0x72
@@ -325,25 +321,25 @@ static int synaptics_ts_remove(struct i2c_client *client);
 static int synaptics_ts_probe(struct i2c_client *client, const struct i2c_device_id *id);
 static ssize_t synaptics_rmi4_baseline_show(struct device *dev, char *buf, bool savefile)	;
 static ssize_t synaptics_rmi4_vendor_id_show(struct device *dev, struct device_attribute *attr, char *buf);
-static int synapitcs_ts_update(struct i2c_client *client, const uint8_t *data, uint32_t data_len ,bool force);
+static int synapitcs_ts_update(struct i2c_client *client, const uint8_t *data, uint32_t data_len, bool force);
 
 static int synaptics_rmi4_i2c_read_block(struct i2c_client* client,
-		unsigned char addr,unsigned short length,unsigned char *data);
+        unsigned char addr, unsigned short length, unsigned char *data);
 
 static int synaptics_rmi4_i2c_write_block(struct i2c_client* client,
-		unsigned char addr, unsigned short length, unsigned char const *data);
+        unsigned char addr, unsigned short length, unsigned char const *data);
 
 static int synaptics_rmi4_i2c_read_byte(struct i2c_client* client,
-		unsigned char addr);
+                                        unsigned char addr);
 
 static int synaptics_rmi4_i2c_write_byte(struct i2c_client* client,
-		unsigned char addr,unsigned char data);
+        unsigned char addr, unsigned char data);
 
 static int synaptics_rmi4_i2c_read_word(struct i2c_client* client,
-		unsigned char addr);
+                                        unsigned char addr);
 
 static int synaptics_rmi4_i2c_write_word(struct i2c_client* client,
-		unsigned char addr,unsigned short data);
+        unsigned char addr, unsigned short data);
 static int synaptics_mode_change(int mode);
 
 #ifdef TPD_USE_EINT
@@ -356,7 +352,7 @@ static int fb_notifier_callback(struct notifier_block *self, unsigned long event
 static int synaptics_soft_reset(struct synaptics_ts_data *ts);
 static void synaptics_hard_reset(struct synaptics_ts_data *ts);
 static int set_changer_bit(struct synaptics_ts_data *ts);
-static int tp_baseline_get(struct synaptics_ts_data *ts,bool flag);
+static int tp_baseline_get(struct synaptics_ts_data *ts, bool flag);
 
 /*-------------------------------Using Struct----------------------------------*/
 struct point_info {
@@ -367,7 +363,7 @@ struct point_info {
 	int raw_y;
 	int z;
 #ifdef REPORT_2D_PRESSURE
-    unsigned char pressure;
+	unsigned char pressure;
 #endif
 };
 
@@ -393,7 +389,7 @@ static const struct dev_pm_ops synaptic_pm_ops = {
 
 //add by jiachenghui for boot time optimize 2015-5-13
 static int probe_ret;
-struct synaptics_optimize_data{
+struct synaptics_optimize_data {
 	struct delayed_work work;
 	struct workqueue_struct *workqueue;
 	struct i2c_client *client;
@@ -404,8 +400,8 @@ static void synaptics_ts_probe_func(struct work_struct *w)
 {
 	struct i2c_client *client_optimize = optimize_data.client;
 	const struct i2c_device_id *dev_id = optimize_data.dev_id;
-	TPD_ERR("after on cpu [%d]\n",smp_processor_id());
-	probe_ret = synaptics_ts_probe(client_optimize,dev_id);
+	TPD_ERR("after on cpu [%d]\n", smp_processor_id());
+	probe_ret = synaptics_ts_probe(client_optimize, dev_id);
 }
 
 static int oem_synaptics_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
@@ -415,16 +411,18 @@ static int oem_synaptics_ts_probe(struct i2c_client *client, const struct i2c_de
 	optimize_data.dev_id = id;
 	optimize_data.workqueue = create_workqueue("tpd_probe_optimize");
 	INIT_DELAYED_WORK(&(optimize_data.work), synaptics_ts_probe_func);
-	TPD_ERR("before on cpu [%d]\n",smp_processor_id());
+	TPD_ERR("before on cpu [%d]\n", smp_processor_id());
 
 	//add by lifeng@bsp 2015-12-10 for only one cpu on line
-	for (i = 0; i < NR_CPUS; i++){
-         TPD_ERR("check CPU[%d] is [%s]\n",i,cpu_is_offline(i)?"offline":"online");
-		 if (cpu_online(i) && (i != smp_processor_id()))
-            break;
-    }
-    queue_delayed_work_on(i != NR_CPUS?i:0,optimize_data.workqueue,&(optimize_data.work),msecs_to_jiffies(300));
-    //end add by lifeng@bsp 2015-12-10 for only one cpu on line
+	for (i = 0; i < NR_CPUS; i++) {
+		TPD_ERR("check CPU[%d] is [%s]\n", i, cpu_is_offline(i) ? "offline" : "online");
+
+		if (cpu_online(i) && (i != smp_processor_id()))
+			break;
+	}
+
+	queue_delayed_work_on(i != NR_CPUS ? i : 0, optimize_data.workqueue, &(optimize_data.work), msecs_to_jiffies(300));
+	//end add by lifeng@bsp 2015-12-10 for only one cpu on line
 
 	return probe_ret;
 }
@@ -482,13 +480,17 @@ struct synaptics_ts_data {
 	struct notifier_block fb_notif;
 #endif
 	/******gesture*******/
-	int gesture_enable;
+	uint32_t gestures_enable;
 	int in_gesture_mode;
 	int glove_enable;
-    int changer_connet;
+	int changer_connet;
 	int is_suspended;
-    atomic_t is_stop;
-    spinlock_t lock;
+	atomic_t is_stop;
+	spinlock_t lock;
+
+	/******button keys******/
+	bool key_swap;
+	bool key_disable;
 
 	/********test*******/
 	int i2c_device_test;
@@ -505,13 +507,13 @@ struct synaptics_ts_data {
 
 	/*******for FW update*******/
 	bool loading_fw;
-    bool support_ft;//support force touch
+	bool support_ft;//support force touch
 	char fw_name[TP_FW_NAME_MAX_LEN];
 	char test_limit_name[TP_FW_NAME_MAX_LEN];
 	char fw_id[12];
 	char manu_name[30];
 #ifdef SUPPORT_VIRTUAL_KEY
-        struct kobject *properties_kobj;
+	struct kobject *properties_kobj;
 #endif
 };
 
@@ -520,30 +522,34 @@ static struct device_attribute attrs_oem[] = {
 	__ATTR(vendor_id, 0664, synaptics_rmi4_vendor_id_show, NULL),
 };
 
-static void touch_enable (struct synaptics_ts_data *ts)
+static void touch_enable(struct synaptics_ts_data *ts)
 {
-    spin_lock(&ts->lock);
-    if(0 == atomic_read(&ts->irq_enable))
-    {
-        if(ts->irq)
-            enable_irq(ts->irq);
-        atomic_set(&ts->irq_enable,1);
-        //TPD_ERR("test %%%% enable irq\n");
-    }
-    spin_unlock(&ts->lock);
+	spin_lock(&ts->lock);
+
+	if (0 == atomic_read(&ts->irq_enable)) {
+		if (ts->irq)
+			enable_irq(ts->irq);
+
+		atomic_set(&ts->irq_enable, 1);
+		//TPD_ERR("test %%%% enable irq\n");
+	}
+
+	spin_unlock(&ts->lock);
 }
 
 static void touch_disable(struct synaptics_ts_data *ts)
 {
-    spin_lock(&ts->lock);
-    if(1 == atomic_read(&ts->irq_enable))
-    {
-        if(ts->irq)
-            disable_irq_nosync(ts->irq);
-        atomic_set(&ts->irq_enable,0);
-        //TPD_ERR("test ****************** disable irq\n");
-    }
-    spin_unlock(&ts->lock);
+	spin_lock(&ts->lock);
+
+	if (1 == atomic_read(&ts->irq_enable)) {
+		if (ts->irq)
+			disable_irq_nosync(ts->irq);
+
+		atomic_set(&ts->irq_enable, 0);
+		//TPD_ERR("test ****************** disable irq\n");
+	}
+
+	spin_unlock(&ts->lock);
 }
 
 static int tpd_hw_pwron(struct synaptics_ts_data *ts)
@@ -554,80 +560,97 @@ static int tpd_hw_pwron(struct synaptics_ts_data *ts)
 	if (!IS_ERR(ts->vdd_2v8)) {
 		//regulator_set_optimum_mode(ts->vdd_2v8,100000);
 		rc = regulator_enable(ts->vdd_2v8);
-		if(rc){
+
+		if (rc) {
 			dev_err(&ts->client->dev,
-					"Regulator vdd enable failed rc=%d\n", rc);
+			        "Regulator vdd enable failed rc=%d\n", rc);
 			//return rc;
 		}
 	}
-	if( ts->v1p8_gpio > 0 ) {
+
+	if (ts->v1p8_gpio > 0) {
 		TPD_DEBUG("synaptics:enable the v1p8_gpio\n");
 		gpio_direction_output(ts->v1p8_gpio, 1);
 	}
+
 	//msleep(100);
 
-	if( ts->enable2v8_gpio > 0 ) {
+	if (ts->enable2v8_gpio > 0) {
 		TPD_DEBUG("synaptics:enable the enable2v8_gpio\n");
 		gpio_direction_output(ts->enable2v8_gpio, 1);
 	}
-	usleep_range(10*1000, 10*1000);
+
+	usleep_range(10 * 1000, 10 * 1000);
+
 	if (!IS_ERR(ts->vcc_i2c_1v8)) {
 		//regulator_set_optimum_mode(ts->vcc_i2c_1v8,100000);
-		rc = regulator_enable( ts->vcc_i2c_1v8 );
-		if(rc) {
+		rc = regulator_enable(ts->vcc_i2c_1v8);
+
+		if (rc) {
 			dev_err(&ts->client->dev, "Regulator vcc_i2c enable failed rc=%d\n", rc);
 			//return rc;
 		}
 	}
-	usleep_range(10*1000, 10*1000);
-	if( ts->reset_gpio > 0 ) {
+
+	usleep_range(10 * 1000, 10 * 1000);
+
+	if (ts->reset_gpio > 0) {
 		gpio_direction_output(ts->reset_gpio, 1);
-        usleep_range(10*1000, 10*1000);
+		usleep_range(10 * 1000, 10 * 1000);
 		gpio_direction_output(ts->reset_gpio, 0);
-        usleep_range(10*1000, 10*1000);
+		usleep_range(10 * 1000, 10 * 1000);
 		gpio_direction_output(ts->reset_gpio, 1);
 		TPD_DEBUG("synaptics:enable the reset_gpio\n");
 	}
+
 	return rc;
 }
 
 static int tpd_hw_pwroff(struct synaptics_ts_data *ts)
 {
 	int rc = 0;
-	if( ts->reset_gpio > 0 ) {
-		TPD_DEBUG("%s set reset gpio low\n",__func__);
+
+	if (ts->reset_gpio > 0) {
+		TPD_DEBUG("%s set reset gpio low\n", __func__);
 		gpio_direction_output(ts->reset_gpio, 0);
 	}
 
 	if (!IS_ERR(ts->vcc_i2c_1v8)) {
-		rc = regulator_disable( ts->vcc_i2c_1v8 );
-		if(rc) {
+		rc = regulator_disable(ts->vcc_i2c_1v8);
+
+		if (rc) {
 			dev_err(&ts->client->dev, "Regulator vcc_i2c enable failed rc=%d\n", rc);
 			return rc;
 		}
 	}
-	if( ts->v1p8_gpio > 0 ) {
+
+	if (ts->v1p8_gpio > 0) {
 		TPD_DEBUG("synaptics:disable the v1p8_gpio\n");
 		gpio_direction_output(ts->v1p8_gpio, 0);
 	}
+
 	if (!IS_ERR(ts->vdd_2v8)) {
 		rc = regulator_disable(ts->vdd_2v8);
+
 		if (rc) {
 			dev_err(&ts->client->dev, "Regulator vdd disable failed rc=%d\n", rc);
 			return rc;
 		}
 	}
-	if( ts->enable2v8_gpio > 0 ) {
+
+	if (ts->enable2v8_gpio > 0) {
 		TPD_DEBUG("synaptics:enable the enable2v8_gpio\n");
 		gpio_direction_output(ts->enable2v8_gpio, 0);
 	}
+
 	return rc;
 }
 
 static int tpd_power(struct synaptics_ts_data *ts, unsigned int on)
 {
 	int ret;
-	if(on)
+
+	if (on)
 		ret = tpd_hw_pwron(ts);
 	else
 		ret = tpd_hw_pwroff(ts);
@@ -640,13 +663,16 @@ static int synaptics_read_register_map(struct synaptics_ts_data *ts)
 	uint8_t buf[4];
 	int ret;
 	memset(buf, 0, sizeof(buf));
-	ret = synaptics_rmi4_i2c_write_byte( ts->client, 0xff, 0x0 );
-	if( ret < 0 ){
+	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x0);
+
+	if (ret < 0) {
 		TPD_ERR("synaptics_read_register_map: failed for page select\n");
 		return -1;
 	}
+
 	ret = synaptics_rmi4_i2c_read_block(ts->client, 0xDD, 4, &(buf[0x0]));
-	if( ret < 0 ){
+
+	if (ret < 0) {
 		TPD_ERR("failed for page select!\n");
 		return -1;
 	}
@@ -660,7 +686,7 @@ static int synaptics_read_register_map(struct synaptics_ts_data *ts)
 			F12_2D_CMD_BASE  = %x \n\
 			F12_2D_CTRL_BASE	= %x \n\
 			F12_2D_DATA_BASE	= %x \n\
-			",F12_2D_QUERY_BASE,F12_2D_CMD_BASE,F12_2D_CTRL_BASE,F12_2D_DATA_BASE);
+			", F12_2D_QUERY_BASE, F12_2D_CMD_BASE, F12_2D_CTRL_BASE, F12_2D_DATA_BASE);
 
 
 	ret = synaptics_rmi4_i2c_read_block(ts->client, 0xE3, 4, &(buf[0x0]));
@@ -674,7 +700,7 @@ static int synaptics_read_register_map(struct synaptics_ts_data *ts)
 			F01_RMI_DATA_BASE	= %x \n\
 			", F01_RMI_QUERY_BASE, F01_RMI_CMD_BASE, F01_RMI_CTRL_BASE, F01_RMI_DATA_BASE);
 
-	ret = synaptics_rmi4_i2c_read_block( ts->client, 0xE9, 4, &(buf[0x0]) );
+	ret = synaptics_rmi4_i2c_read_block(ts->client, 0xE9, 4, &(buf[0x0]));
 	F34_FLASH_QUERY_BASE = buf[0];
 	F34_FLASH_CMD_BASE = buf[1];
 	F34_FLASH_CTRL_BASE = buf[2];
@@ -685,7 +711,7 @@ static int synaptics_read_register_map(struct synaptics_ts_data *ts)
 			F34_FLASH_DATA_BASE	= %x \n\
 			", F34_FLASH_QUERY_BASE, F34_FLASH_CMD_BASE, F34_FLASH_CTRL_BASE, F34_FLASH_DATA_BASE);
 
-	F01_RMI_QUERY11 = F01_RMI_QUERY_BASE+11;
+	F01_RMI_QUERY11 = F01_RMI_QUERY_BASE + 11;
 	F01_RMI_CTRL00 = F01_RMI_CTRL_BASE;
 	F01_RMI_CTRL01 = F01_RMI_CTRL_BASE + 1;
 	F01_RMI_CMD00 = F01_RMI_CMD_BASE;
@@ -703,10 +729,12 @@ static int synaptics_read_register_map(struct synaptics_ts_data *ts)
 	F34_FLASH_CTRL00 = F34_FLASH_CTRL_BASE;
 
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x4);
-	if( ret < 0 ){
+
+	if (ret < 0) {
 		TPD_DEBUG("synaptics_read_register_map: failed for page select\n");
 		return -1;
 	}
+
 	ret = synaptics_rmi4_i2c_read_block(ts->client, 0xE9, 4, &(buf[0x0]));
 	F51_CUSTOM_QUERY_BASE = buf[0];
 	F51_CUSTOM_CMD_BASE = buf[1];
@@ -724,10 +752,12 @@ static int synaptics_read_register_map(struct synaptics_ts_data *ts)
 
 #if TP_TEST_ENABLE
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x01);
-	if(ret < 0) {
+
+	if (ret < 0) {
 		TPD_ERR("synaptics_read_register_map: failed for page select\n");
 		return -1;
 	}
+
 	ret = synaptics_rmi4_i2c_read_block(ts->client, 0xE9, 4, &(buf[0x0]));
 	F54_ANALOG_QUERY_BASE = buf[0];
 	F54_ANALOG_COMMAND_BASE = buf[1];
@@ -737,7 +767,7 @@ static int synaptics_read_register_map(struct synaptics_ts_data *ts)
 			F54_CMD_BASE  = %x \n\
 			F54_CTRL_BASE	= %x \n\
 			F54_DATA_BASE	= %x \n\
-			", F54_ANALOG_QUERY_BASE, F54_ANALOG_COMMAND_BASE , F54_ANALOG_CONTROL_BASE, F54_ANALOG_DATA_BASE);
+			", F54_ANALOG_QUERY_BASE, F54_ANALOG_COMMAND_BASE, F54_ANALOG_CONTROL_BASE, F54_ANALOG_DATA_BASE);
 #endif
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x00);
 	return 0;
@@ -751,30 +781,36 @@ static int synaptics_enable_interrupt_for_gesture(struct synaptics_ts_data *ts,
 	//chenggang.li@BSP.TP modified for gesture
 	TPD_DEBUG("%s is called\n", __func__);
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x0);
-	if( ret < 0 ) {
+
+	if (ret < 0) {
 		TPD_ERR("%s: select page failed ret = %d\n", __func__, ret);
 		return -1;
 	}
-	ret = i2c_smbus_read_i2c_block_data( ts->client, F12_2D_CTRL20, 3, &(reportbuf[0x0]) );
-	if( ret < 0 ) {
-		TPD_DEBUG("read reg F12_2D_CTRL20[0x%x] failed\n",F12_2D_CTRL20);
+
+	ret = i2c_smbus_read_i2c_block_data(ts->client, F12_2D_CTRL20, 3, &(reportbuf[0x0]));
+
+	if (ret < 0) {
+		TPD_DEBUG("read reg F12_2D_CTRL20[0x%x] failed\n", F12_2D_CTRL20);
 		return -1;
 	}
 
-	if( enable ) {
+	if (enable) {
 		ts->in_gesture_mode = 1;
-		reportbuf[2] |= 0x02 ;
+		reportbuf[2] |= 0x02;
 	} else {
 		ts->in_gesture_mode = 0;
-		reportbuf[2] &= 0xfd ;
+		reportbuf[2] &= 0xfd;
 	}
+
 	TPD_DEBUG("F12_2D_CTRL20:0x%x=[2]:0x%x\n", F12_2D_CTRL20, reportbuf[2]);
-	ret = i2c_smbus_write_i2c_block_data( ts->client, F12_2D_CTRL20, 3, &(reportbuf[0x0]) );
-	if( ret < 0 ){
+	ret = i2c_smbus_write_i2c_block_data(ts->client, F12_2D_CTRL20, 3, &(reportbuf[0x0]));
+
+	if (ret < 0) {
 		TPD_ERR("%s :Failed to write report buffer\n", __func__);
 		return -1;
 	}
-	gesture = UnkownGestrue;
+
+	gesture = GESTURE_NONE;
 	return 0;
 }
 #endif
@@ -785,35 +821,44 @@ static int synaptics_glove_mode_enable(struct synaptics_ts_data *ts)
 {
 	int ret;
 	TPD_DEBUG("glove mode enable\n");
+
 	/* page select = 0x4 */
-	if( 1 == ts->glove_enable)  {
+	if (1 == ts->glove_enable)  {
 		ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x00);
-		if( ret < 0 ){
+
+		if (ret < 0) {
 			TPD_DEBUG("i2c_smbus_write_byte_data failed for mode select\n");
 			goto GLOVE_ENABLE_END;
 		}
+
 		ret = i2c_smbus_read_byte_data(ts->client, GLOVES_ADDR);
 		//TPDTM_DMESG("enable glove  ret is %x ret|0x20 is %x\n", ret, ret|0x20);
 		ret = i2c_smbus_write_byte_data(ts->client, GLOVES_ADDR, ret | 0x01);
-		if( ret < 0 ){
+
+		if (ret < 0) {
 			TPD_DEBUG("i2c_smbus_write_byte_data failed for mode select\n");
 			goto GLOVE_ENABLE_END;
 		}
-	}else{
+	} else {
 		ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x0);
-		if( ret < 0 ){
+
+		if (ret < 0) {
 			TPD_DEBUG("i2c_smbus_write_byte_data failed for mode select\n");
 			goto GLOVE_ENABLE_END;
 		}
+
 		ret = i2c_smbus_read_byte_data(ts->client, GLOVES_ADDR);
 		ret = i2c_smbus_write_byte_data(ts->client, GLOVES_ADDR, ret & 0xFE);
-		if( ret < 0 ){
+
+		if (ret < 0) {
 			TPD_DEBUG("i2c_smbus_write_byte_data failed for mode select\n");
 			goto GLOVE_ENABLE_END;
 		}
 	}
+
 	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x00);
-	if( ret < 0 ){
+
+	if (ret < 0) {
 		TPD_DEBUG("i2c_smbus_write_byte_data failed for page select\n");
 		goto GLOVE_ENABLE_END;
 	}
@@ -829,28 +874,34 @@ static int synaptics_sleep_mode_enable(struct synaptics_ts_data *ts)
 	int ret;
 	/* page select = 0x0 */
 	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x00);
-	if( ret < 0 ){
+
+	if (ret < 0) {
 		TPD_ERR("i2c_smbus_write_byte_data failed for page select\n");
 		goto SLEEP_ENABLE_END;
 	}
-	if( 1 == sleep_enable ){
+
+	if (1 == sleep_enable) {
 		/*0x00:enable glove mode,0x02:disable glove mode,*/
 		TPDTM_DMESG("sleep mode enable\n");
-        ret = synaptics_mode_change(0x01);
-		if( ret < 0 ){
+		ret = synaptics_mode_change(0x01);
+
+		if (ret < 0) {
 			TPD_ERR("i2c_smbus_write_byte_data failed for mode select\n");
 			goto SLEEP_ENABLE_END;
 		}
-	}else{
+	} else {
 		TPDTM_DMESG("sleep mode disable\n");
-        ret = synaptics_mode_change(0x84);
-		if( ret < 0 ){
+		ret = synaptics_mode_change(0x84);
+
+		if (ret < 0) {
 			TPD_ERR("i2c_smbus_write_byte_data failed for mode select\n");
 			goto SLEEP_ENABLE_END;
 		}
 	}
+
 	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x00);
-	if( ret < 0 ){
+
+	if (ret < 0) {
 		TPD_ERR("i2c_smbus_write_byte_data failed for page select\n");
 		goto SLEEP_ENABLE_END;
 	}
@@ -863,20 +914,24 @@ SLEEP_ENABLE_END:
 static int synaptics_read_product_id(struct synaptics_ts_data *ts)
 {
 	uint8_t buf1[11];
-	int ret ;
+	int ret;
 
-	memset(buf1, 0 , sizeof(buf1));
+	memset(buf1, 0, sizeof(buf1));
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x0);
-	if( ret < 0 ){
+
+	if (ret < 0) {
 		TPDTM_DMESG("synaptics_read_product_id: failed for page select\n");
 		return -1;
 	}
+
 	ret = synaptics_rmi4_i2c_read_block(ts->client, F01_RMI_QUERY11, 8, &(buf1[0x0]));
-	ret = synaptics_rmi4_i2c_read_block(ts->client, F01_RMI_QUERY_BASE+19, 2, &(buf1[0x8]));
-	if( ret < 0 ){
+	ret = synaptics_rmi4_i2c_read_block(ts->client, F01_RMI_QUERY_BASE + 19, 2, &(buf1[0x8]));
+
+	if (ret < 0) {
 		TPD_ERR("synaptics_read_product_id: failed to read product info\n");
 		return -1;
 	}
+
 	return 0;
 }
 
@@ -884,20 +939,24 @@ static int synaptics_init_panel(struct synaptics_ts_data *ts)
 {
 	int ret;
 
-	TPD_DEBUG("%s is called!\n",__func__);
+	TPD_DEBUG("%s is called!\n", __func__);
 	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x0);
-	if( ret < 0 ){
+
+	if (ret < 0) {
 		TPD_ERR("init_panel failed for page select\n");
 		return -1;
 	}
+
 	/*device control: normal operation, configur=1*/
 
-    ret = synaptics_mode_change(0x80);//change tp to doze mode
-	if( ret < 0 ){
+	ret = synaptics_mode_change(0x80);//change tp to doze mode
+
+	if (ret < 0) {
 		msleep(150);
-        ret = synaptics_mode_change(0x80);
-		if( ret < 0 ){
-			TPD_ERR("%s failed for mode select\n",__func__);
+		ret = synaptics_mode_change(0x80);
+
+		if (ret < 0) {
+			TPD_ERR("%s failed for mode select\n", __func__);
 		}
 	}
 
@@ -910,29 +969,35 @@ static int synaptics_enable_interrupt(struct synaptics_ts_data *ts, int enable)
 	uint8_t abs_status_int;
 
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x0);
-	if( ret < 0 ) {
+
+	if (ret < 0) {
 		TPDTM_DMESG("synaptics_enable_interrupt: select page failed ret = %d\n",
-		    ret);
+		            ret);
 		return -1;
 	}
-	if( enable ) {
+
+	if (enable) {
 		abs_status_int = 0x7f;
 		/*clear interrupt bits for previous touch*/
-		ret = synaptics_rmi4_i2c_read_byte(ts->client, F01_RMI_DATA_BASE+1);
-		if( ret < 0 ) {
+		ret = synaptics_rmi4_i2c_read_byte(ts->client, F01_RMI_DATA_BASE + 1);
+
+		if (ret < 0) {
 			TPDTM_DMESG("synaptics_enable_interrupt :clear interrupt bits failed\n");
 			return -1;
 		}
 	} else {
 		abs_status_int = 0x0;
 	}
-	ret = synaptics_rmi4_i2c_write_byte(ts->client, F01_RMI_CTRL00+1, abs_status_int);
-	if( ret < 0 ) {
+
+	ret = synaptics_rmi4_i2c_write_byte(ts->client, F01_RMI_CTRL00 + 1, abs_status_int);
+
+	if (ret < 0) {
 		TPDTM_DMESG("%s: enable or disable abs \
 		    interrupt failed,abs_int =%d\n", __func__, abs_status_int);
 		return -1;
 	}
-	ret = synaptics_rmi4_i2c_read_byte(ts->client, F01_RMI_CTRL00+1);
+
+	ret = synaptics_rmi4_i2c_read_byte(ts->client, F01_RMI_CTRL00 + 1);
 	return 0;
 }
 
@@ -940,41 +1005,17 @@ static void delay_qt_ms(unsigned long  w_ms)
 {
 	unsigned long i;
 	unsigned long j;
-	for(i = 0; i < w_ms; i++) {
+
+	for (i = 0; i < w_ms; i++) {
 		for (j = 0; j < 1000; j++) {
 			udelay(1);
 		}
 	}
 }
-/*
-static void int_state(struct synaptics_ts_data *ts)
-{
-	int ret = -1;
-	ret = i2c_smbus_write_byte_data(ts->client, F01_RMI_CMD00, 0x01);
-	if(ret){
-		TPD_ERR("%s:error cannot reset touch panel!\n",__func__);
-		return;
-	}
-	//delay_qt_ms(170);
-	delay_qt_ms(100);
-#ifdef SUPPORT_GLOVES_MODE
-	synaptics_glove_mode_enable(ts);
-#endif
-	ret = synaptics_init_panel(ts);
-	if( ret < 0 ){
-		TPD_DEBUG("%s:error cannot change mode!\n",__func__);
-		return;
-	}
-	ret = synaptics_enable_interrupt(ts, 1);
-	if(ret){
-		TPD_DEBUG("%s:error cannot enable interrupt!\n",__func__);
-		return;
-	}
-}
-*/
+
 //Added for larger than 32 length read!
 static int synaptics_rmi4_i2c_read_block(struct i2c_client* client,
-		unsigned char addr,unsigned short length,unsigned char *data)
+        unsigned char addr, unsigned short length, unsigned char *data)
 {
 	int retval;
 	unsigned char retry;
@@ -994,27 +1035,31 @@ static int synaptics_rmi4_i2c_read_block(struct i2c_client* client,
 		},
 	};
 	buf = addr & 0xFF;
-	for( retry = 0; retry < 2; retry++ ) {
-		if( i2c_transfer(client->adapter, msg, 2) == 2) {
+
+	for (retry = 0; retry < 2; retry++) {
+		if (i2c_transfer(client->adapter, msg, 2) == 2) {
 			retval = length;
 			break;
 		}
+
 		msleep(20);
 	}
-	if( retry == 2 ) {
+
+	if (retry == 2) {
 		dev_err(&client->dev,
-				"%s: I2C read over retry limit\n",
-				__func__);
+		        "%s: I2C read over retry limit\n",
+		        __func__);
 		//rst_flag_counter = 1;//reset tp
 		retval = -5;
 	} else {
 		//rst_flag_counter = 0;
 	}
+
 	return retval;
 }
 
 static int synaptics_rmi4_i2c_write_block(struct i2c_client* client,
-		unsigned char addr, unsigned short length, unsigned char const *data)
+        unsigned char addr, unsigned short length, unsigned char const *data)
 {
 	int retval;
 	unsigned char retry;
@@ -1036,56 +1081,65 @@ static int synaptics_rmi4_i2c_write_block(struct i2c_client* client,
 			retval = length;
 			break;
 		}
+
 		msleep(20);
 	}
+
 	if (retry == 2) {
 		//rst_flag_counter = 1;//rest tp
 		retval = -EIO;
 	} else {
 		//rst_flag_counter = 0;
 	}
+
 	return retval;
 }
 
 static int synaptics_rmi4_i2c_read_byte(struct i2c_client* client,
-		unsigned char addr)
+                                        unsigned char addr)
 {
 	int retval = 0;
 	unsigned char buf[2] = {0};
-	retval = synaptics_rmi4_i2c_read_block(client,addr,1,buf);
-	if(retval >= 0)
-		retval = buf[0]&0xff;
+	retval = synaptics_rmi4_i2c_read_block(client, addr, 1, buf);
+
+	if (retval >= 0)
+		retval = buf[0] & 0xff;
+
 	return retval;
 }
 
 static int synaptics_rmi4_i2c_write_byte(struct i2c_client* client,
-		unsigned char addr,unsigned char data)
+        unsigned char addr, unsigned char data)
 {
 	int retval;
 	unsigned char data_send = data;
-	retval = synaptics_rmi4_i2c_write_block(client,addr,1,&data_send);
+	retval = synaptics_rmi4_i2c_write_block(client, addr, 1, &data_send);
 	return retval;
 }
 
 static int synaptics_rmi4_i2c_read_word(struct i2c_client* client,
-		unsigned char addr)
+                                        unsigned char addr)
 {
 	int retval;
 	unsigned char buf[2] = {0};
-	retval = synaptics_rmi4_i2c_read_block(client,addr,2,buf);
-	if(retval >= 0)
-		retval = buf[1]<<8|buf[0];
+	retval = synaptics_rmi4_i2c_read_block(client, addr, 2, buf);
+
+	if (retval >= 0)
+		retval = buf[1] << 8 | buf[0];
+
 	return retval;
 }
 
 static int synaptics_rmi4_i2c_write_word(struct i2c_client* client,
-		unsigned char addr,unsigned short data)
+        unsigned char addr, unsigned short data)
 {
 	int retval;
-	unsigned char buf[2] = {data&0xff,(data>>8)&0xff};
-	retval = synaptics_rmi4_i2c_write_block(client,addr,2,buf);
-	if(retval >= 0)
-		retval = buf[1]<<8|buf[0];
+	unsigned char buf[2] = {data & 0xff, (data >> 8) & 0xff};
+	retval = synaptics_rmi4_i2c_write_block(client, addr, 2, buf);
+
+	if (retval >= 0)
+		retval = buf[1] << 8 | buf[0];
+
 	return retval;
 }
 
@@ -1094,40 +1148,40 @@ static int synaptics_rmi4_i2c_write_word(struct i2c_client* client,
 #ifdef SUPPORT_GESTURE
 static void synaptics_get_coordinate_point(struct synaptics_ts_data *ts)
 {
-	int ret,i;
+	int ret, i;
 	uint8_t coordinate_buf[25] = {0};
 	uint16_t trspoint = 0;
-/* add by lifeng 2016/1/19 workarounds for the gestrue two interrupts begin*/
-	static uint8_t coordinate_buf_last[25]= {0};
-/* add by lifeng 2016/1/19 workarounds for the gestrue two interrupts end*/
+	/* add by lifeng 2016/1/19 workarounds for the gestrue two interrupts begin*/
+	static uint8_t coordinate_buf_last[25] = {0};
+	/* add by lifeng 2016/1/19 workarounds for the gestrue two interrupts end*/
 
-	TPD_DEBUG("%s is called!\n",__func__);
+	TPD_DEBUG("%s is called!\n", __func__);
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x4);
 	ret = i2c_smbus_read_i2c_block_data(ts->client, F51_CUSTOM_DATA11, 8, &(coordinate_buf[0]));
 	ret = i2c_smbus_read_i2c_block_data(ts->client, F51_CUSTOM_DATA11 + 8, 8, &(coordinate_buf[8]));
 	ret = i2c_smbus_read_i2c_block_data(ts->client, F51_CUSTOM_DATA11 + 16, 8, &(coordinate_buf[16]));
 	ret = i2c_smbus_read_i2c_block_data(ts->client, F51_CUSTOM_DATA11 + 24, 1, &(coordinate_buf[24]));
 
-/* add by lifeng 2016/1/19 workarounds for the gestrue two interrupts begin*/
-    if(!memcmp(coordinate_buf_last,coordinate_buf,sizeof(coordinate_buf)))
-    {
-        TPD_ERR("%s reject the same gestrue[%d]\n",__func__,gesture);
-        gesture = UnkownGestrue;
-    }
-	memcpy(coordinate_buf_last,coordinate_buf,sizeof(coordinate_buf));
-   // strcpy(coordinate_buf_last,coordinate_buf/*,sizeof(coordinate_buf)*/);
-/* add by lifeng 2016/1/19 workarounds for the gestrue two interrupts end*/
+	/* add by lifeng 2016/1/19 workarounds for the gestrue two interrupts begin*/
+	if (!memcmp(coordinate_buf_last, coordinate_buf, sizeof(coordinate_buf))) {
+		TPD_ERR("%s reject the same gestrue[%d]\n", __func__, gesture);
+		gesture = GESTURE_NONE;
+	}
+
+	memcpy(coordinate_buf_last, coordinate_buf, sizeof(coordinate_buf));
+	// strcpy(coordinate_buf_last,coordinate_buf/*,sizeof(coordinate_buf)*/);
+	/* add by lifeng 2016/1/19 workarounds for the gestrue two interrupts end*/
 
-	for(i = 0; i< 23; i += 2) {
-		trspoint = coordinate_buf[i]|coordinate_buf[i+1] << 8;
-		TPD_DEBUG("synaptics TP read coordinate_point[%d] = %d\n",i,trspoint);
+	for (i = 0; i < 23; i += 2) {
+		trspoint = coordinate_buf[i] | coordinate_buf[i + 1] << 8;
+		TPD_DEBUG("synaptics TP read coordinate_point[%d] = %d\n", i, trspoint);
 	}
 
-	TPD_DEBUG("synaptics TP coordinate_buf = 0x%x\n",coordinate_buf[24]);
+	TPD_DEBUG("synaptics TP coordinate_buf = 0x%x\n", coordinate_buf[24]);
 
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x0);
-	Point_start.x = (coordinate_buf[0] | (coordinate_buf[1] << 8)) * LCD_WIDTH/ (ts->max_x);
-	Point_start.y = (coordinate_buf[2] | (coordinate_buf[3] << 8)) * LCD_HEIGHT/ (ts->max_y);
+	Point_start.x = (coordinate_buf[0] | (coordinate_buf[1] << 8)) * LCD_WIDTH / (ts->max_x);
+	Point_start.y = (coordinate_buf[2] | (coordinate_buf[3] << 8)) * LCD_HEIGHT / (ts->max_y);
 	Point_end.x   = (coordinate_buf[4] | (coordinate_buf[5] << 8)) * LCD_WIDTH / (ts->max_x);
 	Point_end.y   = (coordinate_buf[6] | (coordinate_buf[7] << 8)) * LCD_HEIGHT / (ts->max_y);
 	Point_1st.x   = (coordinate_buf[8] | (coordinate_buf[9] << 8)) * LCD_WIDTH / (ts->max_x);
@@ -1139,161 +1193,217 @@ static void synaptics_get_coordinate_point(struct synaptics_ts_data *ts)
 	Point_4th.x   = (coordinate_buf[20] | (coordinate_buf[21] << 8)) * LCD_WIDTH / (ts->max_x);
 	Point_4th.y   = (coordinate_buf[22] | (coordinate_buf[23] << 8)) * LCD_HEIGHT / (ts->max_y);
 	clockwise     = (coordinate_buf[24] & 0x10) ? 1 :
-		(coordinate_buf[24] & 0x20) ? 0 : 2; // 1--clockwise, 0--anticlockwise, not circle, report 2
+	                (coordinate_buf[24] & 0x20) ? 0 : 2; // 1--clockwise, 0--anticlockwise, not circle, report 2
 }
 
 static void gesture_judge(struct synaptics_ts_data *ts)
 {
-	unsigned int keyCode = KEY_F4;
-	int ret = 0,gesture_sign, regswipe;
+	unsigned int keyCode = 0;
+
+	int ret = 0;
+	int regswipe;
+
 	uint8_t gesture_buffer[10];
 	unsigned char reportbuf[3];
-        if(version_is_s3508)
+
+	if (version_is_s3508)
 		F12_2D_DATA04 = 0x0008;
 	else
- 		F12_2D_DATA04 = 0x000A;
-	TPD_DEBUG("%s start!\n",__func__);
+		F12_2D_DATA04 = 0x000A;
+
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x00);
+
 	if (ret < 0) {
 		TPDTM_DMESG("failed to transfer the data, ret = %d\n", ret);
 	}
-	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x00);
-	ret = i2c_smbus_read_i2c_block_data(ts->client,  F12_2D_DATA04, 5, &(gesture_buffer[0]));
-	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x4);
-	if(version_is_s3508)
-		regswipe = i2c_smbus_read_byte_data(ts->client, F51_CUSTOM_DATA04+0x18);
-	else
-		regswipe = i2c_smbus_read_byte_data(ts->client, F51_CUSTOM_DATA04+0x18);
-	if(version_is_s3508)
-		TPD_DEBUG("s35080Gesture Type[0x%x]=[0x%x],lpwg Swipe ID[0x4%x] = [0x%x]\n",\
-		F12_2D_DATA04,gesture_buffer[0],(F51_CUSTOM_DATA04+0x18),regswipe);
-	else
-		TPD_DEBUG("Gesture Type[0x%x]=[0x%x],lpwg Swipe ID[0x4%x] = [0x%x]\n",\
-		F12_2D_DATA04,gesture_buffer[0],(F51_CUSTOM_DATA04+0x18),regswipe);
-	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x00);
-	gesture_sign = gesture_buffer[0];
-	//detect the gesture mode
-	switch (gesture_sign) {
-		case DTAP_DETECT:
-			    gesture = DouTap;
+
+	i2c_smbus_write_byte_data(ts->client, 0xff, 0x00);
+	i2c_smbus_read_i2c_block_data(ts->client, F12_2D_DATA04, 5, &(gesture_buffer[0]));
+
+	i2c_smbus_write_byte_data(ts->client, 0xff, 0x4);
+	regswipe = i2c_smbus_read_byte_data(ts->client, F51_CUSTOM_DATA04 + 0x18);
+
+	i2c_smbus_write_byte_data(ts->client, 0xff, 0x00);
+
+	// detect the gesture mode
+	switch (gesture_buffer[0]) {
+	case DTAP_DETECT:
+		gesture = GESTURE_DOUBLE_TAP;
+		break;
+
+	case SWIPE_DETECT:
+		switch (regswipe) {
+		case 0x41:
+			gesture = GESTURE_RIGHT_SWIPE;
 			break;
-		case SWIPE_DETECT:
-			if(version_is_s3508){
-				gesture =   (regswipe == 0x41) ? Left2RightSwip   :
-					(regswipe == 0x42) ? Right2LeftSwip   :
-					(regswipe == 0x44) ? Up2DownSwip      :
-					(regswipe == 0x48) ? Down2UpSwip      :
-					(regswipe == 0x80) ? DouSwip          :
-					UnkownGestrue;
-				break;
-			}else{
-				gesture = (regswipe == 0x41) ? Left2RightSwip   :
-					(regswipe == 0x42) ? Right2LeftSwip   :
-					(regswipe == 0x44) ? Up2DownSwip      :
-					(regswipe == 0x48) ? Down2UpSwip      :
-					(regswipe == 0x84) ? DouSwip          :
-					UnkownGestrue;
-				break;
-			}
-		case CIRCLE_DETECT:
-			    gesture = Circle;
+
+		case 0x42:
+			gesture = GESTURE_LEFT_SWIPE;
 			break;
-		case VEE_DETECT:
-			gesture = (gesture_buffer[2] == 0x01) ? DownVee  :
-				(gesture_buffer[2] == 0x02) ? UpVee    :
-				(gesture_buffer[2] == 0x04) ? RightVee :
-				(gesture_buffer[2] == 0x08) ? LeftVee  :
-				UnkownGestrue;
+
+		case 0x44:
+			gesture = GESTURE_DOWN_SWIPE;
 			break;
-		case UNICODE_DETECT:
-			gesture = (gesture_buffer[2] == 0x77) ? Wgestrue :
-				(gesture_buffer[2] == 0x6d) ? Mgestrue :
-				(gesture_buffer[2] == 0x73) ? Sgestrue :
-				UnkownGestrue;
-            //#endif, ruanbanmao@bsp 2015-05-06, end.
-	}
 
-// carlo@oneplus.net 2015-05-25, begin.
-/*
-	keyCode = UnkownGestrue;
-	// Get key code based on registered gesture.
-	switch (gesture) {
-		case DouTap:
-			keyCode = KEY_DOUBLE_TAP;
+		case 0x48:
+			gesture = GESTURE_UP_SWIPE;
+			break;
+
+		case 0x80:
+			gesture = version_is_s3508
+			          ? GESTURE_DOUBLE_SWIPE : GESTURE_NONE;
+			break;
+
+		case 0x84:
+			gesture = !version_is_s3508
+			          ? GESTURE_DOUBLE_SWIPE : GESTURE_NONE;
 			break;
-		case UpVee:
-			keyCode = KEY_GESTURE_V;
+
+		default:
+			gesture = GESTURE_NONE;
 			break;
-		case DownVee:
-			keyCode = KEY_GESTURE_V;
+		}
+
+		break;
+
+	case CIRCLE_DETECT:
+		gesture = GESTURE_CIRCLE;
+		break;
+
+	case VEE_DETECT:
+		switch (gesture_buffer[2]) {
+		case 0x01:
+			gesture = GESTURE_UP_ARROW;
 			break;
-		case LeftVee:
-			keyCode = KEY_GESTURE_RIGHT_V;
+
+		case 0x02:
+			gesture = GESTURE_DOWN_ARROW;
 			break;
-		case RightVee:
-			keyCode = KEY_GESTURE_LEFT_V;
+
+		case 0x04:
+			gesture = GESTURE_LEFT_ARROW;
 			break;
-		case Circle:
-			keyCode = KEY_GESTURE_CIRCLE;
+
+		case 0x08:
+			gesture = GESTURE_RIGHT_ARROW;
 			break;
-		case DouSwip:
-			keyCode = KEY_GESTURE_TWO_SWIPE;
+
+		default:
+			gesture = GESTURE_NONE;
 			break;
-		case Wgestrue:
-			keyCode = KEY_GESTURE_W;
+		}
+
+		break;
+
+	case UNICODE_DETECT:
+		switch (gesture_buffer[2]) {
+		case 0x77:
+			gesture = GESTURE_W;
 			break;
-		case Mgestrue:
-			keyCode = KEY_GESTURE_M;
+
+		case 0x6d:
+			gesture = GESTURE_M;
 			break;
-		case Sgestrue:
-			keyCode = KEY_GESTURE_S;
+
+		case 0x73:
+			gesture = GESTURE_S;
 			break;
+
 		default:
+			gesture = GESTURE_NONE;
 			break;
+		}
+
+		break;
+	}
+
+	// Get key code based on registered gesture.
+	switch (gesture) {
+	case GESTURE_DOUBLE_TAP:
+		keyCode = KEY_DOUBLE_TAP;
+		break;
+
+	case GESTURE_UP_ARROW:
+		keyCode = KEY_GESTURE_UP_ARROW;
+		break;
+
+	case GESTURE_DOWN_ARROW:
+		keyCode = KEY_GESTURE_DOWN_ARROW;
+		break;
+
+	case GESTURE_LEFT_ARROW:
+		keyCode = KEY_GESTURE_LEFT_ARROW;
+		break;
+
+	case GESTURE_RIGHT_ARROW:
+		keyCode = KEY_GESTURE_RIGHT_ARROW;
+		break;
+
+	case GESTURE_CIRCLE:
+		keyCode = KEY_GESTURE_CIRCLE;
+		break;
+
+	case GESTURE_DOUBLE_SWIPE:
+		keyCode = KEY_GESTURE_TWO_SWIPE;
+		break;
+
+	case GESTURE_LEFT_SWIPE:
+		keyCode = KEY_GESTURE_SWIPE_LEFT;
+		break;
+
+	case GESTURE_RIGHT_SWIPE:
+		keyCode = KEY_GESTURE_SWIPE_RIGHT;
+		break;
+
+	case GESTURE_UP_SWIPE:
+		keyCode = KEY_GESTURE_SWIPE_UP;
+		break;
+
+	case GESTURE_DOWN_SWIPE:
+		keyCode = KEY_GESTURE_SWIPE_DOWN;
+		break;
+
+	case GESTURE_W:
+		keyCode = KEY_GESTURE_W;
+		break;
+
+	case GESTURE_M:
+		keyCode = KEY_GESTURE_M;
+		break;
+
+	case GESTURE_S:
+		keyCode = KEY_GESTURE_S;
+		break;
+
+	default:
+		break;
 	}
-// carlo@oneplus.net 2015-05-25, end.
-*/
-
-	TPD_ERR("detect %s gesture\n", gesture == DouTap ? "(double tap)" :
-			gesture == UpVee ? "(V)" :
-			gesture == DownVee ? "(^)" :
-			gesture == LeftVee ? "(>)" :
-			gesture == RightVee ? "(<)" :
-			gesture == Circle ? "(O)" :
-			gesture == DouSwip ? "(||)" :
-			gesture == Left2RightSwip ? "(-->)" :
-			gesture == Right2LeftSwip ? "(<--)" :
-			gesture == Up2DownSwip ? "(up to down |)" :
-			gesture == Down2UpSwip ? "(down to up |)" :
-			gesture == Mgestrue ? "(M)" :
-			gesture == Sgestrue ? "(S)" :
-			gesture == Wgestrue ? "(W)" : "[unknown]");
+
 	synaptics_get_coordinate_point(ts);
 
-    TPD_DEBUG("gesture suport LeftVee:%d RightVee:%d DouSwip:%d Circle:%d UpVee:%d DouTap:%d\n",\
-        LeftVee_gesture,RightVee_gesture,DouSwip_gesture,Circle_gesture,UpVee_gesture,DouTap_gesture);
-	if((gesture == DouTap && DouTap_gesture)||(gesture == RightVee && RightVee_gesture)\
-        ||(gesture == LeftVee && LeftVee_gesture)||(gesture == UpVee && UpVee_gesture)\
-        ||(gesture == Circle && Circle_gesture)||(gesture == DouSwip && DouSwip_gesture)\
-	||gesture == Sgestrue || gesture == Wgestrue || gesture == Mgestrue){
+	if ((gesture & ts->gestures_enable) != 0) {
 		gesture_upload = gesture;
 		input_report_key(ts->input_dev, keyCode, 1);
 		input_sync(ts->input_dev);
 		input_report_key(ts->input_dev, keyCode, 0);
 		input_sync(ts->input_dev);
-	}else{
-
-		ret = i2c_smbus_read_i2c_block_data( ts->client, F12_2D_CTRL20, 3, &(reportbuf[0x0]) );
+	} else {
+		ret = i2c_smbus_read_i2c_block_data(ts->client, F12_2D_CTRL20, 3, &(reportbuf[0x0]));
 		ret = reportbuf[2] & 0x20;
-		if(ret == 0)
-			reportbuf[2] |= 0x02 ;
-		ret = i2c_smbus_write_i2c_block_data( ts->client, F12_2D_CTRL20, 3, &(reportbuf[0x0]) ); //enable gesture
-		if( ret < 0 ){
+
+		if (ret == 0) {
+			reportbuf[2] |= 0x02;
+		}
+
+		ret = i2c_smbus_write_i2c_block_data(ts->client, F12_2D_CTRL20, 3, &(reportbuf[0x0])); //enable gesture
+
+		if (ret < 0) {
 			TPD_ERR("%s :Failed to write report buffer\n", __func__);
 			return;
 		}
 	}
-    TPD_DEBUG("%s end!\n",__func__);
+
+	TPD_DEBUG("%s end!\n", __func__);
 }
 #endif
 /***************end****************/
@@ -1301,16 +1411,18 @@ static char prlog_count = 0;
 #ifdef REPORT_2D_PRESSURE
 static unsigned char pres_value = 1;
 #endif
+
 #ifdef SUPPORT_VIRTUAL_KEY //WayneChang, 2015/12/02, add for key to abs, simulate key in abs through virtual key system
 //extern struct completion key_cm;
 bool key_back_pressed = 0;
 bool key_appselect_pressed = 0;
-bool key_home_pressed =0;
+bool key_home_pressed = 0;
 extern bool virtual_key_enable;
 #endif
+
 void int_touch(void)
 {
-	int ret = -1,i = 0;
+	int ret = -1, i = 0;
 	uint8_t buf[90];
 	uint8_t count_data = 0;
 	uint8_t object_attention[2];
@@ -1320,7 +1432,7 @@ void int_touch(void)
 	struct point_info points;
 	uint32_t finger_info = 0;
 	static uint8_t current_status = 0;
-	uint8_t last_status = 0 ;
+	uint8_t last_status = 0;
 #ifdef SUPPORT_VIRTUAL_KEY //WayneChang, 2015/12/02, add for key to abs, simulate key in abs through virtual key system
 	bool key_appselect_check = false;
 	bool key_back_check = false;
@@ -1337,114 +1449,128 @@ void int_touch(void)
 
 	mutex_lock(&ts->mutexreport);
 #ifdef REPORT_2D_PRESSURE
-    if (ts->support_ft){
-        ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x4);
-        ret = synaptics_rmi4_i2c_read_block(ts->client, 0x19,\
-            sizeof(points.pressure), &points.pressure);
-        if (ret < 0) {
-            TPD_ERR("synaptics_int_touch: i2c_transfer failed\n");
-            goto INT_TOUCH_END;
-        }
-        if (0 == points.pressure)//workaround for have no pressure value input reader into hover mode
-        {
-            pres_value++;
-            if (255 == pres_value)
-                pres_value = 1;
-        }
-        else
-        {
-            pres_value = points.pressure;
-        }
-    }
+
+	if (ts->support_ft) {
+		ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x4);
+		ret = synaptics_rmi4_i2c_read_block(ts->client, 0x19, \
+		                                    sizeof(points.pressure), &points.pressure);
+
+		if (ret < 0) {
+			TPD_ERR("synaptics_int_touch: i2c_transfer failed\n");
+			goto INT_TOUCH_END;
+		}
+
+		if (0 == points.pressure) { //workaround for have no pressure value input reader into hover mode
+			pres_value++;
+
+			if (255 == pres_value)
+				pres_value = 1;
+		} else {
+			pres_value = points.pressure;
+		}
+	}
+
 #endif
 	ret = i2c_smbus_write_byte_data(ts->client, 0xff, 0x0);
-	if(version_is_s3508)
+
+	if (version_is_s3508)
 		F12_2D_DATA15 = 0x0009;
 	else
 		F12_2D_DATA15 = 0x000C;
+
 	ret = synaptics_rmi4_i2c_read_block(ts->client, F12_2D_DATA15, 2, object_attention);
-    if (ret < 0) {
-        TPD_ERR("synaptics_int_touch F12_2D_DATA15: i2c_transfer failed\n");
-        goto INT_TOUCH_END;
-    }
+
+	if (ret < 0) {
+		TPD_ERR("synaptics_int_touch F12_2D_DATA15: i2c_transfer failed\n");
+		goto INT_TOUCH_END;
+	}
+
 	total_status = (object_attention[1] << 8) | object_attention[0];
 
-	if(total_status){
-		while(total_status){
+	if (total_status) {
+		while (total_status) {
 			count_data++;
 			total_status >>= 1;
 		}
-	}else{
+	} else {
 		count_data = 0;
 	}
-        if(count_data > 10){
-            TPD_ERR("count_data is: %d\n", count_data);
-            goto INT_TOUCH_END;
-        }
-	ret = synaptics_rmi4_i2c_read_block(ts->client, F12_2D_DATA_BASE, count_data*8+1, buf);
+
+	if (count_data > 10) {
+		TPD_ERR("count_data is: %d\n", count_data);
+		goto INT_TOUCH_END;
+	}
+
+	ret = synaptics_rmi4_i2c_read_block(ts->client, F12_2D_DATA_BASE, count_data * 8 + 1, buf);
+
 	if (ret < 0) {
 		TPD_ERR("synaptics_int_touch F12_2D_DATA_BASE: i2c_transfer failed\n");
 		goto INT_TOUCH_END;
 	}
-	for( i = 0; i < count_data; i++ ) {
-		points.status = buf[i*8];
-		points.x = ((buf[i*8+2]&0x0f)<<8) | (buf[i*8+1] & 0xff);
-		points.raw_x = buf[i*8+6] & 0x0f;
-		points.y = ((buf[i*8+4]&0x0f)<<8) | (buf[i*8+3] & 0xff);
-		points.raw_y = buf[i*8+7] & 0x0f;
-		points.z = buf[i*8+5];
+	for (i = 0; i < count_data; i++) {
+		points.status = buf[i * 8];
+		points.x = ((buf[i * 8 + 2] & 0x0f) << 8) | (buf[i * 8 + 1] & 0xff);
+		points.raw_x = buf[i * 8 + 6] & 0x0f;
+		points.y = ((buf[i * 8 + 4] & 0x0f) << 8) | (buf[i * 8 + 3] & 0xff);
+		points.raw_y = buf[i * 8 + 7] & 0x0f;
+		points.z = buf[i * 8 + 5];
 		finger_info <<= 1;
 		finger_status =  points.status & 0x03;
 #ifdef SUPPORT_VIRTUAL_KEY //WayneChang, 2015/12/02, add for key to abs, simulate key in abs through virtual key system
-            if(virtual_key_enable){
-                if(points.y > 0x780 && key_pressed){
-                        TPD_DEBUG("Drop TP event due to key pressed\n");
-                        finger_status = 0;
-                }else{
-                    finger_status =  points.status & 0x03;
-                }
-            }else{
-                finger_status =  points.status & 0x03;
-            }
-            if(virtual_key_enable){
-                    if (!finger_status){
-                        if (key_appselect_pressed && !key_appselect_check){
-                            points.x = 0xb4;
-                            points.y = 0x7e2;
-                            points.z = 0x33;
-                            points.raw_x = 4;
-                            points.raw_y = 6;
-                            key_appselect_check = true;
-                            points.status = 1;
-                            finger_status =  points.status & 0x03;
-                        }else if (key_back_pressed && !key_back_check){
-                            points.x = 0x384;
-                            points.y = 0x7e2;
-                            points.z = 0x33;
-                            points.raw_x = 4;
-                            points.raw_y = 6;
-                            key_back_check = true;
-                            points.status = 1;
-                            finger_status =  points.status & 0x03;
-                        }else if(key_home_pressed && !key_home_check){
-                            points.x = 0x21c;
-                            points.y = 0x7e2;
-                            points.z = 0x33;
-                            points.raw_x = 4;
-                            points.raw_y = 6;
-                            key_home_check = true;
-                            points.status = 1;
-                            finger_status =  points.status & 0x03;
-                    }else{
-                            //TPD_DEBUG(" finger %d with !finger_statue and no key match\n",i);
-                        }
-                    }
-            }
+
+		if (virtual_key_enable) {
+			if (points.y > 0x780 && key_pressed) {
+				TPD_DEBUG("Drop TP event due to key pressed\n");
+				finger_status = 0;
+			} else {
+				finger_status =  points.status & 0x03;
+			}
+		} else {
+			finger_status =  points.status & 0x03;
+		}
+
+		if (virtual_key_enable) {
+			if (!finger_status) {
+				if (key_appselect_pressed && !key_appselect_check) {
+					points.x = 0xb4;
+					points.y = 0x7e2;
+					points.z = 0x33;
+					points.raw_x = 4;
+					points.raw_y = 6;
+					key_appselect_check = true;
+					points.status = 1;
+					finger_status =  points.status & 0x03;
+				} else if (key_back_pressed && !key_back_check) {
+					points.x = 0x384;
+					points.y = 0x7e2;
+					points.z = 0x33;
+					points.raw_x = 4;
+					points.raw_y = 6;
+					key_back_check = true;
+					points.status = 1;
+					finger_status =  points.status & 0x03;
+				} else if (key_home_pressed && !key_home_check) {
+					points.x = 0x21c;
+					points.y = 0x7e2;
+					points.z = 0x33;
+					points.raw_x = 4;
+					points.raw_y = 6;
+					key_home_check = true;
+					points.status = 1;
+					finger_status =  points.status & 0x03;
+				} else {
+					//TPD_DEBUG(" finger %d with !finger_statue and no key match\n",i);
+				}
+			}
+		}
+
 #endif
-		if (version_is_s3508 == 0){//for 15811 panel
+
+		if (version_is_s3508 == 0) { //for 15811 panel
 			points.x = 1079 - points.x;
 			points.y = 1919 - points.y;
 		}
+
 		if (finger_status) {
 			input_mt_slot(ts->input_dev, i);
 			input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, finger_status);
@@ -1456,34 +1582,38 @@ void int_touch(void)
 			input_report_abs(ts->input_dev, ABS_MT_TOUCH_MINOR, min(points.raw_x, points.raw_y));
 			//#endif
 #ifdef REPORT_2D_PRESSURE
-            if (ts->support_ft){
-                input_report_abs(ts->input_dev,ABS_MT_PRESSURE,pres_value);
-                TPD_DEBUG("%s: pressure%d[%d]\n",__func__,i,pres_value);
-            }
+
+			if (ts->support_ft) {
+				input_report_abs(ts->input_dev, ABS_MT_PRESSURE, pres_value);
+				TPD_DEBUG("%s: pressure%d[%d]\n", __func__, i, pres_value);
+			}
+
 #endif
 #ifndef TYPE_B_PROTOCOL
 			input_mt_sync(ts->input_dev);
 #endif
 #ifdef SUPPORT_VIRTUAL_KEY //WayneChang, 2015/12/02, add for key to abs, simulate key in abs through virtual key system
-            if(virtual_key_enable){
-              //  complete(&key_cm);
-            }
+
+			if (virtual_key_enable) {
+				//  complete(&key_cm);
+			}
+
 #endif
 			finger_num++;
-			finger_info |= 1 ;
+			finger_info |= 1;
 			//TPD_DEBUG("%s: Finger %d: status = 0x%02x "
-					//"x = %4d, y = %4d, wx = %2d, wy = %2d\n",
-					//__func__, i, points.status, points.x, points.y, points.raw_x, points.raw_y);
+			//"x = %4d, y = %4d, wx = %2d, wy = %2d\n",
+			//__func__, i, points.status, points.x, points.y, points.raw_x, points.raw_y);
 
 		}
 	}
+
 	finger_info <<= (ts->max_num - count_data);
 
-	for ( i = 0; i < ts->max_num; i++ )
-	{
-		finger_status = (finger_info>>(ts->max_num-i-1)) & 1 ;
-		if(!finger_status)
-		{
+	for (i = 0; i < ts->max_num; i++) {
+		finger_status = (finger_info >> (ts->max_num - i - 1)) & 1;
+
+		if (!finger_status) {
 			input_mt_slot(ts->input_dev, i);
 			input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, finger_status);
 		}
@@ -1501,122 +1631,131 @@ void int_touch(void)
 		input_mt_sync(ts->input_dev);
 #endif
 	}
+
 	input_sync(ts->input_dev);
 
-	if ((finger_num == 0) && (get_tp_base == 0)){//all finger up do get base once
+	if ((finger_num == 0) && (get_tp_base == 0)) { //all finger up do get base once
 		get_tp_base = 1;
-		TPD_ERR("start get base data:%d\n",get_tp_base);
+		TPD_ERR("start get base data:%d\n", get_tp_base);
 		tp_baseline_get(ts, false);
 	}
 
 #ifdef SUPPORT_GESTURE
+
 	if (ts->in_gesture_mode == 1 && ts->is_suspended == 1) {
 		gesture_judge(ts);
 	}
+
 #endif
-    INT_TOUCH_END:
+
+INT_TOUCH_END:
 	mutex_unlock(&ts->mutexreport);
 }
-static char log_count = 0;
-#ifdef SUPPORT_TP_TOUCHKEY
-#define OEM_KEY_BACK (key_switch?KEY_APPSELECT:KEY_BACK)
-#define OEM_KEY_APPSELECT (key_switch?KEY_BACK:KEY_APPSELECT)
-#else
-#define OEM_KEY_BACK KEY_BACK
-#define OEM_KEY_APPSELECT KEY_APPSELECT
-#endif
+
 static void int_key_report_s3508(struct synaptics_ts_data *ts)
 {
-    	int ret= 0;
-	int F1A_0D_DATA00=0x00;
+	int ret = 0;
+	int F1A_0D_DATA00 = 0x00;
 	int button_key;
 
-	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x02 );
+	int keycode_left;
+	int keycode_right;
+
+	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x02);
+
 	if (ret < 0) {
-		TPD_ERR("%s: line[%d]Failed to change page!!\n",__func__,__LINE__);
+		TPD_ERR("%s: line[%d]Failed to change page!!\n", __func__, __LINE__);
 		return;
-	 }
-	button_key = synaptics_rmi4_i2c_read_byte(ts->client,F1A_0D_DATA00);
-	if (1 == (++log_count % 4))
-		TPD_ERR("touch_key[0x%x],touchkey_state[0x%x]\n",button_key,ts->pre_btn_state);
-	if((button_key & 0x01) && !(ts->pre_btn_state & 0x01) && !key_back_disable)//back
-	{
-		input_report_key(ts->input_dev, OEM_KEY_BACK, 1);
-		input_sync(ts->input_dev);
-	}else if(!(button_key & 0x01) && (ts->pre_btn_state & 0x01) && !key_back_disable){
-		input_report_key(ts->input_dev, OEM_KEY_BACK, 0);
-		input_sync(ts->input_dev);
 	}
 
-	if((button_key & 0x02) && !(ts->pre_btn_state & 0x02) && !key_appselect_disable)//menu
-	{
-		input_report_key(ts->input_dev, OEM_KEY_APPSELECT, 1);
-		input_sync(ts->input_dev);
-	}else if(!(button_key & 0x02) && (ts->pre_btn_state & 0x02) && !key_appselect_disable){
-		input_report_key(ts->input_dev, OEM_KEY_APPSELECT, 0);
-		input_sync(ts->input_dev);
+	button_key = synaptics_rmi4_i2c_read_byte(ts->client, F1A_0D_DATA00);
+
+	if (ts->key_swap) {
+		keycode_left = KEY_BUTTON_RIGHT;
+		keycode_right = KEY_BUTTON_LEFT;
+	} else {
+		keycode_left = KEY_BUTTON_LEFT;
+		keycode_right = KEY_BUTTON_RIGHT;
 	}
 
-	ts->pre_btn_state = button_key & 0x07;
-	//input_sync(ts->input_dev);
+	if (!ts->key_disable) {
+		if ((button_key & BUTTON_LEFT) && !(ts->pre_btn_state & BUTTON_LEFT)) {
+			input_report_key(ts->input_dev, keycode_left, 1);
+			input_sync(ts->input_dev);
+		} else if (!(button_key & BUTTON_LEFT) && (ts->pre_btn_state & BUTTON_LEFT)) {
+			input_report_key(ts->input_dev, keycode_left, 0);
+			input_sync(ts->input_dev);
+		}
+
+		if ((button_key & BUTTON_RIGHT) && !(ts->pre_btn_state & BUTTON_RIGHT)) {
+			input_report_key(ts->input_dev, keycode_right, 1);
+			input_sync(ts->input_dev);
+		} else if (!(button_key & BUTTON_RIGHT) && (ts->pre_btn_state & BUTTON_RIGHT)) {
+			input_report_key(ts->input_dev, keycode_right, 0);
+			input_sync(ts->input_dev);
+		}
+	}
+
+	ts->pre_btn_state = button_key & (BUTTON_LEFT | BUTTON_RIGHT);
+
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x00);
+
 	if (ret < 0) {
-		TPD_ERR("%s: line[%d]Failed to change page!!\n",__func__,__LINE__);
+		TPD_ERR("%s: line[%d]Failed to change page!!\n", __func__, __LINE__);
 		return;
 	}
+
 	return;
 }
 
 static void synaptics_ts_work_func(struct work_struct *work)
 {
-	int ret,status_check;
+	int ret, status_check;
 	uint8_t status = 0;
 	uint8_t inte = 0;
 
-    	struct synaptics_ts_data *ts = ts_g;
+	struct synaptics_ts_data *ts = ts_g;
 
-	if (atomic_read(&ts->is_stop) == 1)
-	{
+	if (atomic_read(&ts->is_stop) == 1) {
 		touch_disable(ts);
 		return;
 	}
 
-	if( ts->enable_remote) {
+	if (ts->enable_remote) {
 		goto END;
 	}
-	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x00 );
+
+	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x00);
 	ret = synaptics_rmi4_i2c_read_word(ts->client, F01_RMI_DATA_BASE);
 
-	if( ret < 0 ) {
+	if (ret < 0) {
 		TPDTM_DMESG("Synaptic:ret = %d\n", ret);
-        synaptics_hard_reset(ts);
+		synaptics_hard_reset(ts);
 		goto END;
 	}
+
 	status = ret & 0xff;
-	inte = (ret & 0x7f00)>>8;
+	inte = (ret & 0x7f00) >> 8;
+
 	//TPD_ERR("%s status[0x%x],inte[0x%x]\n",__func__,status,inte);
-        if(status & 0x80){
-		TPD_DEBUG("enter reset tp status,and ts->in_gesture_mode is:%d\n",ts->in_gesture_mode);
+	if (status & 0x80) {
+		TPD_DEBUG("enter reset tp status,and ts->in_gesture_mode is:%d\n", ts->in_gesture_mode);
 		status_check = synaptics_init_panel(ts);
+
 		if (status_check < 0) {
 			TPD_ERR("synaptics_init_panel failed\n");
 		}
-		if ((ts->is_suspended == 1) && (ts->gesture_enable == 1)){
+
+		if (ts->is_suspended == 1 && ts->gestures_enable != 0) {
 			synaptics_enable_interrupt_for_gesture(ts, 1);
 		}
 	}
-/*
-	if(0 != status && 1 != status) {//0:no error;1: after hard reset;the two state don't need soft reset
-        TPD_ERR("%s status[0x%x],inte[0x%x]\n",__func__,status,inte);
-		int_state(ts);
-		goto END;
-	}
-*/
-	if( inte & 0x04 ) {
 
+	if (inte & 0x04) {
 		int_touch();
 	}
-	if( inte & 0x10 ){
+
+	if (inte & 0x10) {
 		int_key_report_s3508(ts);
 	}
 
@@ -1641,7 +1780,7 @@ static enum hrtimer_restart synaptics_ts_timer_func(struct hrtimer *timer)
 static irqreturn_t synaptics_irq_thread_fn(int irq, void *dev_id)
 {
 	struct synaptics_ts_data *ts = (struct synaptics_ts_data *)dev_id;
-    touch_disable(ts);
+	touch_disable(ts);
 	synaptics_ts_work_func(&ts->report_work);
 	return IRQ_HANDLED;
 }
@@ -1652,14 +1791,17 @@ static ssize_t tp_baseline_test_read_func(struct file *file, char __user *user_b
 {
 	char page[PAGESIZE];
 	struct synaptics_ts_data *ts = ts_g;
-	if(!ts)
+
+	if (!ts)
 		return baseline_ret;
-	if(baseline_ret == 0){
-		count = synaptics_rmi4_baseline_show(ts->dev,page,1);
+
+	if (baseline_ret == 0) {
+		count = synaptics_rmi4_baseline_show(ts->dev, page, 1);
 		baseline_ret = simple_read_from_buffer(user_buf, count, ppos, page, strlen(page));
-	}else{
+	} else {
 		baseline_ret = 0;
 	}
+
 	return baseline_ret;
 }
 //wangwenxue@BSP add for change baseline_test to "proc\touchpanel\baseline_test"  end
@@ -1669,152 +1811,84 @@ static ssize_t i2c_device_test_read_func(struct file *file, char __user *user_bu
 	int ret = 0;
 	char page[PAGESIZE];
 	struct synaptics_ts_data *ts = ts_g;
-	if(!ts_g)
+
+	if (!ts_g)
 		return ret;
-	TPD_DEBUG("gesture enable is: %d\n", ts->gesture_enable);
+
+	TPD_DEBUG("gesture enable is: %d\n", ts->gestures_enable);
 	ret = sprintf(page, "%d\n", ts->i2c_device_test);
 	ret = simple_read_from_buffer(user_buf, count, ppos, page, strlen(page));
 	return ret;
 }
 
 #ifdef SUPPORT_GESTURE
-static ssize_t tp_gesture_read_func(struct file *file, char __user *user_buf, size_t count, loff_t *ppos)
-{
-	int ret = 0;
-	char page[PAGESIZE];
-	struct synaptics_ts_data *ts = ts_g;
-	if(!ts)
-		return ret;
-	TPD_DEBUG("gesture enable is: %d\n", ts->gesture_enable);
-	ret = sprintf(page, "%d\n", ts->gesture_enable);
-	ret = simple_read_from_buffer(user_buf, count, ppos, page, strlen(page));
-	return ret;
-}
-
-static ssize_t tp_gesture_write_func(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
-{
-	char buf[10];
-	struct synaptics_ts_data *ts = ts_g;
-	if(!ts)
-		return count;
-	if( count > 3 || ts->is_suspended)
-		return count;
-	if( copy_from_user(buf, buffer, count) ){
-		TPD_ERR(KERN_INFO "%s: read proc input error.\n", __func__);
-		return count;
-	}
-	//ruanbanmao@BSP add for tp gesture 2015-05-06, begin
-	TPD_ERR("%s write argc1[0x%x],argc2[0x%x]\n",__func__,buf[0],buf[1]);
-
-	UpVee_gesture = (buf[0] & BIT0)?1:0; //"V"
-	DouSwip_gesture = (buf[0] & BIT1)?1:0;//"||"
-	LeftVee_gesture = (buf[0] & BIT3)?1:0; //">"
-	RightVee_gesture = (buf[0] & BIT4)?1:0;//"<"
-	Circle_gesture = (buf[0] & BIT6)?1:0; //"O"
-	DouTap_gesture = (buf[0] & BIT7)?1:0; //double tap
-
-	Sgestrue_gesture = (buf[1] & BIT0)?1:0;//"S"
-	Mgestrue_gesture = (buf[1] & BIT1)?1:0; //"M"
-	Wgestrue_gesture = (buf[1] & BIT2)?1:0; //"W"
-
-	if(DouTap_gesture||Circle_gesture||UpVee_gesture||LeftVee_gesture\
-      ||RightVee_gesture||DouSwip_gesture||Sgestrue_gesture||Mgestrue_gesture||Wgestrue_gesture)
-	{
-		ts->gesture_enable = 1;
-	}
-	else
-	{
-		ts->gesture_enable = 0;
-	}
-    //ruanbanmao@BSP add for tp gesture 2015-05-06, end
-	return count;
-}
 static ssize_t coordinate_proc_read_func(struct file *file, char __user *user_buf, size_t count, loff_t *ppos)
 {
 	int ret = 0;
 	char page[PAGESIZE];
-	TPD_ERR("%s:gesture_upload = %d \n",__func__,gesture_upload);
+	TPD_ERR("%s:gesture_upload = %d \n", __func__, gesture_upload);
 	ret = sprintf(page, "%d,%d:%d,%d:%d,%d:%d,%d:%d,%d:%d,%d:%d,%d\n", gesture_upload,
-			Point_start.x, Point_start.y, Point_end.x, Point_end.y,
-			Point_1st.x, Point_1st.y, Point_2nd.x, Point_2nd.y,
-			Point_3rd.x, Point_3rd.y, Point_4th.x, Point_4th.y,
-			clockwise);
-
-	ret = simple_read_from_buffer(user_buf, count, ppos, page, strlen(page));
-	return ret;
-}
+	              Point_start.x, Point_start.y, Point_end.x, Point_end.y,
+	              Point_1st.x, Point_1st.y, Point_2nd.x, Point_2nd.y,
+	              Point_3rd.x, Point_3rd.y, Point_4th.x, Point_4th.y,
+	              clockwise);
 
-static ssize_t gesture_switch_read_func(struct file *file, char __user *user_buf, size_t count, loff_t *ppos)
-{
-	int ret = 0;
-	char page[PAGESIZE];
-	struct synaptics_ts_data *ts = ts_g;
-	if(!ts)
-		return ret;
-	ret = sprintf(page, "gesture_switch:%d\n", gesture_switch);
 	ret = simple_read_from_buffer(user_buf, count, ppos, page, strlen(page));
 	return ret;
 }
 
-static ssize_t gesture_switch_write_func(struct file *file, const char __user *page, size_t count, loff_t *ppos)
-{
-	int ret,write_flag=0;
-	char buf[10]={0};
-	struct synaptics_ts_data *ts = ts_g;
-
-	if(ts->loading_fw) {
-		TPD_ERR("%s FW is updating break!!\n",__func__);
-		return count;
-	}
-	if( copy_from_user(buf, page, count) ){
-		TPD_ERR("%s: read proc input error.\n", __func__);
-		return count;
-	}
-	ret = sscanf(buf,"%d",&write_flag);
-	gesture_switch = write_flag;
-	TPD_ERR("gesture_switch:%d,suspend:%d,gesture:%d\n",gesture_switch,ts->is_suspended,ts->gesture_enable);
-	if (1 == gesture_switch){
-		if ((ts->is_suspended == 1) && (ts->gesture_enable == 1)){
-			i2c_smbus_write_byte_data(ts->client, 0xff, 0x0);
-			synaptics_mode_change(0x80);
-			//touch_enable(ts);
-			synaptics_enable_interrupt_for_gesture(ts, 1);
-		}
-	}else if(2 == gesture_switch){
-		if ((ts->is_suspended == 1) && (ts->gesture_enable == 1)){
-			i2c_smbus_write_byte_data(ts->client, 0xff, 0x0);
-			synaptics_mode_change(0x81);
-			//touch_disable(ts);
-			synaptics_enable_interrupt_for_gesture(ts, 0);
-		}
-	}
-
-	return count;
-}
-
-// chenggang.li@BSP.TP modified for oem 2014-08-08 create node
-/******************************start****************************/
-static const struct file_operations tp_gesture_proc_fops = {
-	.write = tp_gesture_write_func,
-	.read =  tp_gesture_read_func,
-	.open = simple_open,
-	.owner = THIS_MODULE,
-};
-
-static const struct file_operations gesture_switch_proc_fops = {
-	.write = gesture_switch_write_func,
-	.read =  gesture_switch_read_func,
-	.open = simple_open,
-	.owner = THIS_MODULE,
-};
-
 static const struct file_operations coordinate_proc_fops = {
 	.read =  coordinate_proc_read_func,
 	.open = simple_open,
 	.owner = THIS_MODULE,
 };
+
+#define GESTURE_ATTR(name, flag)\
+	static ssize_t name##_enable_read_func(struct file *file, char __user *user_buf, size_t count, loff_t *ppos)\
+	{\
+		int ret = 0;\
+		char page[PAGESIZE];\
+		ret = sprintf(page, "%d\n", (ts_g->gestures_enable & flag) != 0);\
+		ret = simple_read_from_buffer(user_buf, count, ppos, page, strlen(page));\
+		return ret;\
+	}\
+	static ssize_t name##_enable_write_func(struct file *file, const char __user *user_buf, size_t count, loff_t *ppos)\
+	{\
+		int ret, write_flag = 0;\
+		char page[PAGESIZE] = {0};\
+		ret = copy_from_user(page, user_buf, count);\
+		ret = sscanf(page, "%d", &write_flag);\
+		if (write_flag) {\
+			ts_g->gestures_enable |= flag;\
+		} else {\
+			ts_g->gestures_enable &= ~flag;\
+		}\
+		return count;\
+	}\
+	static const struct file_operations name##_enable_proc_fops = {\
+	    .write = name##_enable_write_func,\
+	    .read =  name##_enable_read_func,\
+	    .open = simple_open,\
+	    .owner = THIS_MODULE,\
+	};
+
+GESTURE_ATTR(double_tap, GESTURE_DOUBLE_TAP);
+GESTURE_ATTR(up_arrow, GESTURE_UP_ARROW);
+GESTURE_ATTR(down_arrow, GESTURE_DOWN_ARROW);
+GESTURE_ATTR(left_arrow, GESTURE_LEFT_ARROW);
+GESTURE_ATTR(right_arrow, GESTURE_RIGHT_ARROW);
+GESTURE_ATTR(double_swipe, GESTURE_DOUBLE_SWIPE);
+GESTURE_ATTR(up_swipe, GESTURE_UP_SWIPE);
+GESTURE_ATTR(down_swipe, GESTURE_DOWN_SWIPE);
+GESTURE_ATTR(left_swipe, GESTURE_LEFT_SWIPE);
+GESTURE_ATTR(right_swipe, GESTURE_RIGHT_SWIPE);
+GESTURE_ATTR(letter_o, GESTURE_CIRCLE);
+GESTURE_ATTR(letter_w, GESTURE_W);
+GESTURE_ATTR(letter_m, GESTURE_M);
+GESTURE_ATTR(letter_s, GESTURE_S);
 #endif
-static int page ,address,block;
+
+static int page, address, block;
 static ssize_t synap_read_address(struct file *file, char __user *user_buf, size_t count, loff_t *ppos)
 {
 	int ret;
@@ -1824,15 +1898,16 @@ static ssize_t synap_read_address(struct file *file, char __user *user_buf, size
 	int cnt = 0;
 
 	struct synaptics_ts_data *ts = ts_g;
-	TPD_DEBUG("%s page=0x%x,address=0x%x,block=0x%x\n",__func__,page,address,block);
-	cnt += sprintf(&(buffer[cnt]), "page=0x%x,address=0x%x,block=0x%x\n",page,address,block);
-	ret = synaptics_rmi4_i2c_write_byte(ts->client,0xff,page);
-	ret = synaptics_rmi4_i2c_read_block(ts->client,address,block,buf);
-	for (i=0;i < block;i++)
-	{
-		cnt += sprintf(&(buffer[cnt]), "buf[%d]=0x%x\n",i,buf[i]);
-		TPD_DEBUG("buffer[%d]=0x%x\n",i,buffer[i]);
+	TPD_DEBUG("%s page=0x%x,address=0x%x,block=0x%x\n", __func__, page, address, block);
+	cnt += sprintf(&(buffer[cnt]), "page=0x%x,address=0x%x,block=0x%x\n", page, address, block);
+	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, page);
+	ret = synaptics_rmi4_i2c_read_block(ts->client, address, block, buf);
+
+	for (i = 0; i < block; i++) {
+		cnt += sprintf(&(buffer[cnt]), "buf[%d]=0x%x\n", i, buf[i]);
+		TPD_DEBUG("buffer[%d]=0x%x\n", i, buffer[i]);
 	}
+
 	ret = simple_read_from_buffer(user_buf, count, ppos, buffer, strlen(buffer));
 	return ret;
 }
@@ -1840,39 +1915,40 @@ static ssize_t synap_read_address(struct file *file, char __user *user_buf, size
 static ssize_t synap_write_address(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
 {
 	int buf[128];
-    int ret,i;
+	int ret, i;
 	struct synaptics_ts_data *ts = ts_g;
-    int temp_block,wbyte;
-    char reg[30];
-
-    ret = sscanf(buffer,"%x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x",\
-    &buf[0],&buf[1],&buf[2],&buf[3],&buf[4],&buf[5],&buf[6],&buf[7],&buf[8],&buf[9],\
-    &buf[10],&buf[11],&buf[12],&buf[13],&buf[14],&buf[15],&buf[16],&buf[17]);
-    for (i = 0;i < ret;i++)
-    {
-        TPD_DEBUG("buf[i]=0x%x,",buf[i]);
-    }
-    TPD_DEBUG("\n");
-    page= buf[0];
-    address = buf[1];
-    temp_block = buf[2];
-    wbyte = buf[3];
-    if (0xFF == temp_block)//the  mark is to write register else read register
-    {
-        for (i=0;i < wbyte;i++)
-        {
-            reg[i] = (char)buf[4+i];
-        }
-        ret = synaptics_rmi4_i2c_write_byte(ts->client,0xff,page);
-        ret = synaptics_rmi4_i2c_write_block(ts->client,(char)address,wbyte,reg);
-        TPD_DEBUG("%s write page=0x%x,address=0x%x\n",__func__,page,address);
-        for (i=0;i < wbyte;i++)
-        {
-            TPD_DEBUG("reg=0x%x\n",reg[i]);
-        }
-    }
-    else
-        block = temp_block;
+	int temp_block, wbyte;
+	char reg[30];
+
+	ret = sscanf(buffer, "%x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x", \
+	             &buf[0], &buf[1], &buf[2], &buf[3], &buf[4], &buf[5], &buf[6], &buf[7], &buf[8], &buf[9], \
+	             &buf[10], &buf[11], &buf[12], &buf[13], &buf[14], &buf[15], &buf[16], &buf[17]);
+
+	for (i = 0; i < ret; i++) {
+		TPD_DEBUG("buf[i]=0x%x,", buf[i]);
+	}
+
+	TPD_DEBUG("\n");
+	page = buf[0];
+	address = buf[1];
+	temp_block = buf[2];
+	wbyte = buf[3];
+
+	if (0xFF == temp_block) { //the  mark is to write register else read register
+		for (i = 0; i < wbyte; i++) {
+			reg[i] = (char)buf[4 + i];
+		}
+
+		ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, page);
+		ret = synaptics_rmi4_i2c_write_block(ts->client, (char)address, wbyte, reg);
+		TPD_DEBUG("%s write page=0x%x,address=0x%x\n", __func__, page, address);
+
+		for (i = 0; i < wbyte; i++) {
+			TPD_DEBUG("reg=0x%x\n", reg[i]);
+		}
+	} else
+		block = temp_block;
+
 	return count;
 }
 
@@ -1882,8 +1958,10 @@ static ssize_t tp_glove_read_func(struct file *file, char __user *user_buf, size
 	int ret = 0;
 	char page[PAGESIZE];
 	struct synaptics_ts_data *ts = ts_g;
-	if(!ts)
+
+	if (!ts)
 		return ret;
+
 	TPD_DEBUG("glove mode enable is: %d\n", ts->glove_enable);
 	ret = sprintf(page, "%d\n", ts->glove_enable);
 	ret = simple_read_from_buffer(user_buf, count, ppos, page, strlen(page));
@@ -1892,40 +1970,48 @@ static ssize_t tp_glove_read_func(struct file *file, char __user *user_buf, size
 
 static ssize_t tp_glove_write_func(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
 {
-	struct synaptics_ts_data *ts= ts_g;
-	int ret = 0 ;
-	char buf[10]={0};
+	struct synaptics_ts_data *ts = ts_g;
+	int ret = 0;
+	char buf[10] = {0};
 
-	if( count > 10 )
+	if (count > 10)
 		goto GLOVE_ENABLE_END;
-	if( copy_from_user( buf, buffer, count) ){
+
+	if (copy_from_user(buf, buffer, count)) {
 		TPD_ERR("%s: read proc input error.\n", __func__);
 		goto GLOVE_ENABLE_END;
 	}
+
 	sscanf(buf, "%d", &ret);
-	if(!ts)
+
+	if (!ts)
 		return count;
+
 	TPDTM_DMESG("tp_glove_write_func:buf = %d,ret = %d\n", *buf, ret);
-	if( (ret == 0 ) || (ret == 1) ){
+
+	if ((ret == 0) || (ret == 1)) {
 		ts->glove_enable = ret;
 		synaptics_glove_mode_enable(ts);
 	}
-	switch(ret){
-		case 0:
-			TPDTM_DMESG("tp_glove_func will be disable\n");
-			break;
-		case 1:
-			TPDTM_DMESG("tp_glove_func will be enable\n");
-			break;
-		default:
-			TPDTM_DMESG("Please enter 0 or 1 to open or close the glove function\n");
+
+	switch (ret) {
+	case 0:
+		TPDTM_DMESG("tp_glove_func will be disable\n");
+		break;
+
+	case 1:
+		TPDTM_DMESG("tp_glove_func will be enable\n");
+		break;
+
+	default:
+		TPDTM_DMESG("Please enter 0 or 1 to open or close the glove function\n");
 	}
+
 GLOVE_ENABLE_END:
 	return count;
 }
 #endif
 
-
 #ifdef SUPPORT_TP_SLEEP_MODE
 static ssize_t tp_sleep_read_func(struct file *file, char __user *user_buf, size_t count, loff_t *ppos)
 {
@@ -1939,33 +2025,42 @@ static ssize_t tp_sleep_read_func(struct file *file, char __user *user_buf, size
 
 static ssize_t tp_sleep_write_func(struct file *file, const char *buffer, size_t count, loff_t *ppos)
 {
-	char buf[10]={0};
+	char buf[10] = {0};
 	struct synaptics_ts_data *ts = ts_g;
-	int ret = 0 ;
-	if( count > 10 )
+	int ret = 0;
+
+	if (count > 10)
 		return count;
-	if(!ts)
+
+	if (!ts)
 		return count;
-	if( copy_from_user( buf, buffer, count) ) {
+
+	if (copy_from_user(buf, buffer, count)) {
 		TPD_ERR(KERN_INFO "%s: read proc input error.\n", __func__);
 		return count;
 	}
+
 	sscanf(buf, "%d", &ret);
 	TPDTM_DMESG("tp_sleep_write_func:buf = %d,ret = %d\n", *buf, ret);
-	if( (ret == 0 ) || (ret == 1) ) {
+
+	if ((ret == 0) || (ret == 1)) {
 		sleep_enable = ret;
 		synaptics_sleep_mode_enable(ts);
 	}
-	switch(ret) {
-		case 0:
-			TPDTM_DMESG("tp_sleep_func will be disable\n");
-			break;
-		case 1:
-			TPDTM_DMESG("tp_sleep_func will be enable\n");
-			break;
-		default:
-			TPDTM_DMESG("Please enter 0 or 1 to open or close the sleep function\n");
+
+	switch (ret) {
+	case 0:
+		TPDTM_DMESG("tp_sleep_func will be disable\n");
+		break;
+
+	case 1:
+		TPDTM_DMESG("tp_sleep_func will be enable\n");
+		break;
+
+	default:
+		TPDTM_DMESG("Please enter 0 or 1 to open or close the sleep function\n");
 	}
+
 	return count;
 }
 #endif
@@ -1974,39 +2069,49 @@ static ssize_t tp_show(struct device_driver *ddri, char *buf)
 {
 	// uint8_t ret = 0;
 	struct synaptics_ts_data *ts = ts_g;
-	int a ;
-	int b,c;
-	if(!ts)
+	int a;
+	int b, c;
+
+	if (!ts)
 		return 0;
+
 	a = synaptics_rmi4_i2c_read_word(ts->client, F01_RMI_DATA_BASE);
-	if( a < 0 )
+
+	if (a < 0)
 		TPD_ERR("tp_show read i2c err\n");
+
 	b = synaptics_rmi4_i2c_read_byte(ts->client, F01_RMI_DATA01);
-	if( b < 0 )
+
+	if (b < 0)
 		TPD_ERR("tp_show read i2c err\n");
+
 	c = synaptics_rmi4_i2c_read_byte(ts->client, F12_2D_DATA_BASE);
-	if( c < 0 )
+
+	if (c < 0)
 		TPD_ERR("tp_show read i2c err\n");
 
 	return sprintf(buf, "F01_RMI_DATA_BASE[0x%x]=0x%x;F01_RMI_DATA01[0x%x]=0x%x;F12_2D_DATA_BASE[0x%x]=0x%x;\n", \
-			F01_RMI_DATA_BASE,a,F01_RMI_DATA01,b,F12_2D_DATA_BASE,c);
+	               F01_RMI_DATA_BASE, a, F01_RMI_DATA01, b, F12_2D_DATA_BASE, c);
 }
 
 static ssize_t store_tp(struct device_driver *ddri, const char *buf, size_t count)
 {
 	int tmp = 0;
-	if( 1 == sscanf(buf, "%d", &tmp) ){
+
+	if (1 == sscanf(buf, "%d", &tmp)) {
 		tp_debug = tmp;
 	} else {
 		TPDTM_DMESG("invalid content: '%s', length = %zd\n", buf, count);
 	}
+
 	return count;
 }
+
 static ssize_t vendor_id_read_func(struct file *file, char __user *user_buf, size_t count, loff_t *ppos)
 {
 	int ret = 0;
 	char page[4];
-	ret = sprintf(page, "%d\n",7);
+	ret = sprintf(page, "%d\n", 7);
 	ret = simple_read_from_buffer(user_buf, count, ppos, page, strlen(page));
 	return ret;
 }
@@ -2017,10 +2122,12 @@ static int synaptics_read_register_map_page1(struct synaptics_ts_data *ts)
 	unsigned char buf[4];
 	int ret;
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x1);
-	if( ret < 0 ) {
+
+	if (ret < 0) {
 		TPD_ERR("synaptics_rmi4_i2c_write_byte failed for page select\n");
 		return -1;
 	}
+
 	ret = synaptics_rmi4_i2c_read_block(ts->client, 0xE9, 4, &(buf[0x0]));
 	F54_ANALOG_QUERY_BASE = buf[0];
 	F54_ANALOG_COMMAND_BASE = buf[1];
@@ -2031,7 +2138,7 @@ static int synaptics_read_register_map_page1(struct synaptics_ts_data *ts)
 			F54_ANALOG_COMMAND_BASE  = 0x%x \n\
 			F54_ANALOG_CONTROL_BASE	 = 0x%x \n\
 			F54_ANALOG_DATA_BASE	 = 0x%x \n\
-			",F54_ANALOG_QUERY_BASE,F54_ANALOG_COMMAND_BASE,F54_ANALOG_CONTROL_BASE,F54_ANALOG_DATA_BASE);
+			", F54_ANALOG_QUERY_BASE, F54_ANALOG_COMMAND_BASE, F54_ANALOG_CONTROL_BASE, F54_ANALOG_DATA_BASE);
 	return 0;
 }
 
@@ -2040,28 +2147,32 @@ static void checkCMD(void)
 	int ret;
 	int flag_err = 0;
 	struct synaptics_ts_data *ts = ts_g;
+
 	do {
 		delay_qt_ms(10); //wait 10ms
 		ret = synaptics_rmi4_i2c_read_byte(ts->client, F54_ANALOG_COMMAND_BASE);
 		flag_err++;
-	}while( (ret > 0x00) && (flag_err < 30) );
-	if( ret > 0x00 || flag_err >= 30)
+	} while ((ret > 0x00) && (flag_err < 30));
+
+	if (ret > 0x00 || flag_err >= 30)
 		TPD_ERR("checkCMD error ret is %x flag_err is %d\n", ret, flag_err);
 }
+
 static void checkCMD_RT133(void)
 {
 	int ret = 0;
 	int err_count = 0;
 	struct synaptics_ts_data *ts = ts_g;
+
 	do {
 		delay_qt_ms(10); //wait 10ms
 		ret = synaptics_rmi4_i2c_read_byte(ts->client, F54_ANALOG_COMMAND_BASE);
 		err_count++;
-	}while( (ret & 0x01) && (err_count < 30) );
-	if( ret & 0x01 || err_count >= 30)
+	} while ((ret & 0x01) && (err_count < 30));
+
+	if (ret & 0x01 || err_count >= 30)
 		TPD_ERR("%s line%d %x count %d\n", __func__, __LINE__, ret, err_count);
 }
-
 #endif
 
 static ssize_t tp_baseline_show(struct device_driver *ddri, char *buf)
@@ -2069,14 +2180,16 @@ static ssize_t tp_baseline_show(struct device_driver *ddri, char *buf)
 	int ret = 0;
 	int x, y;
 	ssize_t num_read_chars = 0;
-	uint8_t tmp_l = 0,tmp_h = 0;
+	uint8_t tmp_l = 0, tmp_h = 0;
 	uint16_t tmp_old = 0;
 	uint16_t tmp_new = 0;
 	uint16_t count = 0;
 	struct synaptics_ts_data *ts = ts_g;
-	if(!ts)
+
+	if (!ts)
 		return count;
-	memset(delta_baseline,0,sizeof(delta_baseline));
+
+	memset(delta_baseline, 0, sizeof(delta_baseline));
 	/*disable irq when read data from IC*/
 	touch_disable(ts);
 	mutex_lock(&ts->mutex);
@@ -2086,22 +2199,23 @@ static ssize_t tp_baseline_show(struct device_driver *ddri, char *buf)
 
 	/*step 1:check raw capacitance*/
 	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_DATA_BASE, 0x03);//select report type 0x03
-	if( ret < 0 ){
+
+	if (ret < 0) {
 		TPD_ERR("step 1: select report type 0x03 failed \n");
 		//return sprintf(buf, "i2c err!");
 	}
 
-	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE+20, 0x01);
-	ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_CONTROL_BASE+23);
+	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 20, 0x01);
+	ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 23);
 	tmp_old = ret & 0xff;
-	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE+23, (tmp_old & 0xef));
+	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 23, (tmp_old & 0xef));
 	ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_COMMAND_BASE, 0x04);
-	ret = i2c_smbus_read_byte_data(ts->client,F54_ANALOG_CONTROL_BASE+27);
+	ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 27);
 	tmp_new = ret & 0xdf;
-	i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE+27, tmp_new);
+	i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 27, tmp_new);
 	ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_COMMAND_BASE, 0x04); // force update
 
-	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE+7, 0x01);// Forbid NoiseMitigation
+	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 7, 0x01); // Forbid NoiseMitigation
 
 	ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_COMMAND_BASE, 0x04); // force update
 	checkCMD();
@@ -2109,23 +2223,26 @@ static ssize_t tp_baseline_show(struct device_driver *ddri, char *buf)
 	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_COMMAND_BASE, 0X02);//force Cal
 	checkCMD();
 	//TPDTM_DMESG("Force Cal oK\n");
-	ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_DATA_BASE+1, 0x00);//set fifo 00
+	ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_DATA_BASE + 1, 0x00); //set fifo 00
 	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_COMMAND_BASE, 0x01);//get report
 	checkCMD();
 	count = 0;
-	for( x = 0; x < TX_NUM; x++ ){
+
+	for (x = 0; x < TX_NUM; x++) {
 		//printk("\n[%d]", x);
 		num_read_chars += sprintf(&(buf[num_read_chars]), "\n[%d]", x);
-		for( y = 0; y < RX_NUM; y++ ){
-			ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_DATA_BASE+3);
-			tmp_l = ret&0xff;
-			ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_DATA_BASE+3);
-			tmp_h = ret&0xff;
-			delta_baseline[x][y] = (tmp_h << 8)|tmp_l;
+
+		for (y = 0; y < RX_NUM; y++) {
+			ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_DATA_BASE + 3);
+			tmp_l = ret & 0xff;
+			ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_DATA_BASE + 3);
+			tmp_h = ret & 0xff;
+			delta_baseline[x][y] = (tmp_h << 8) | tmp_l;
 			//printk("%d,", delta_baseline[x][y]);
 			num_read_chars += sprintf(&(buf[num_read_chars]), "%5d", delta_baseline[x][y]);
 		}
 	}
+
 	num_read_chars += sprintf(&(buf[num_read_chars]), "\n");
 	TPD_DEBUG("\nread all is oK\n");
 	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_COMMAND_BASE, 0X02);
@@ -2136,15 +2253,16 @@ static ssize_t tp_baseline_show(struct device_driver *ddri, char *buf)
 #endif
 	synaptics_init_panel(ts);
 //modify by zhouwenping for solve cat tp_baseline_image node cause touch disable 20160225 start
-	synaptics_enable_interrupt(ts,1);
+	synaptics_enable_interrupt(ts, 1);
 	ret = synaptics_soft_reset(ts);
-	if (ret < 0){
-           TPD_ERR("%s faile to reset device\n",__func__);
-        }
+
+	if (ret < 0) {
+		TPD_ERR("%s faile to reset device\n", __func__);
+	}
+
 	mutex_unlock(&ts->mutex);
 //modify by zhouwenping 20160225 end
 	return num_read_chars;
-
 }
 
 static ssize_t tp_rawdata_show(struct device_driver *ddri, char *buf)
@@ -2155,8 +2273,10 @@ static ssize_t tp_rawdata_show(struct device_driver *ddri, char *buf)
 	uint8_t tmp_l = 0, tmp_h = 0;
 	uint16_t count = 0;
 	struct synaptics_ts_data *ts = ts_g;
-	if(!ts)
+
+	if (!ts)
 		return 0;
+
 	memset(delta_baseline, 0, sizeof(delta_baseline));
 	/*disable irq when read data from IC*/
 	touch_disable(ts);
@@ -2166,25 +2286,28 @@ static ssize_t tp_rawdata_show(struct device_driver *ddri, char *buf)
 	//TPD_DEBUG("\nstep 2:report type2 delta image\n");
 	memset(delta_baseline, 0, sizeof(delta_baseline));
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, F54_ANALOG_DATA_BASE, 0x02);//select report type 0x02
-	ret = synaptics_rmi4_i2c_write_word(ts->client, F54_ANALOG_DATA_BASE+1, 0x00);//set fifo 00
+	ret = synaptics_rmi4_i2c_write_word(ts->client, F54_ANALOG_DATA_BASE + 1, 0x00); //set fifo 00
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, F54_ANALOG_COMMAND_BASE, 0X01);//get report
 	checkCMD();
 	count = 0;
-	for( x = 0; x < TX_NUM; x++ ){
+
+	for (x = 0; x < TX_NUM; x++) {
 		//printk("\n[%d]", x);
 		num_read_chars += sprintf(&(buf[num_read_chars]), "\n[%d]", x);
-		for( y = 0; y < RX_NUM; y++ ){
-			ret = synaptics_rmi4_i2c_read_byte(ts->client, F54_ANALOG_DATA_BASE+3);
-			tmp_l = ret&0xff;
-			ret = synaptics_rmi4_i2c_read_byte(ts->client, F54_ANALOG_DATA_BASE+3);
-			tmp_h = ret&0xff;
-			delta_baseline[x][y] = (tmp_h<<8)|tmp_l;
+
+		for (y = 0; y < RX_NUM; y++) {
+			ret = synaptics_rmi4_i2c_read_byte(ts->client, F54_ANALOG_DATA_BASE + 3);
+			tmp_l = ret & 0xff;
+			ret = synaptics_rmi4_i2c_read_byte(ts->client, F54_ANALOG_DATA_BASE + 3);
+			tmp_h = ret & 0xff;
+			delta_baseline[x][y] = (tmp_h << 8) | tmp_l;
 			//printk("%3d,", delta_baseline[x][y]);
 			num_read_chars += sprintf(&(buf[num_read_chars]), "%3d ", delta_baseline[x][y]);
 		}
 	}
+
 	num_read_chars += sprintf(&(buf[num_read_chars]), "\n");
-	ret = i2c_smbus_write_byte_data(ts->client,F54_ANALOG_COMMAND_BASE,0X02);
+	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_COMMAND_BASE, 0X02);
 	delay_qt_ms(60);
 	synaptics_enable_interrupt(ts, 1);
 	mutex_unlock(&ts->mutex);
@@ -2193,7 +2316,7 @@ static ssize_t tp_rawdata_show(struct device_driver *ddri, char *buf)
 }
 
 static ssize_t tp_delta_store(struct device_driver *ddri,
-		const char *buf, size_t count)
+                              const char *buf, size_t count)
 {
 	TPDTM_DMESG("tp_test_store is not support\n");
 	return count;
@@ -2201,23 +2324,22 @@ static ssize_t tp_delta_store(struct device_driver *ddri,
 
 static ssize_t synaptics_rmi4_baseline_show_s3508(struct device *dev, char *buf, bool savefile)
 {
-
 	ssize_t num_read_chars = 0;
 #if TP_TEST_ENABLE
 	int ret = 0;
-	uint8_t x,y;
+	uint8_t x, y;
 	int tx_datal;
 	int16_t baseline_data = 0;
 	uint8_t tmp_old = 0;
 	uint8_t	tmp_new = 0;
-	uint8_t tmp_l = 0,tmp_h = 0;
+	uint8_t tmp_l = 0, tmp_h = 0;
 	uint16_t count = 0;
 	int error_count = 0;
-	uint8_t buffer[9]={0};
+	uint8_t buffer[9] = {0};
 	int16_t *baseline_data_test;
 	int enable_cbc = 0;
-	int readdata_fail=0,first_check=0;
-	int16_t left_ramdata=0,right_ramdata=0;
+	int readdata_fail = 0, first_check = 0;
+	int16_t left_ramdata = 0, right_ramdata = 0;
 	int fd = -1;
 	struct timespec   now_time;
 	struct rtc_time   rtc_now_time;
@@ -2225,20 +2347,7 @@ static ssize_t synaptics_rmi4_baseline_show_s3508(struct device *dev, char *buf,
 	mm_segment_t old_fs;
 
 	struct synaptics_ts_data *ts = dev_get_drvdata(dev);
-	/*
-	   const struct firmware *fw = NULL;
-	   struct test_header *ph = NULL;
-	   ret = request_firmware(&fw, ts->test_limit_name, dev);
-	   if (ret < 0) {
-	   TPD_ERR("Request firmware failed - %s (%d)\n",ts->test_limit_name, ret);
-	   error_count++;
-	   num_read_chars += sprintf(&(buf[num_read_chars]), "imageid=0x%x,deviceid=0x%x\n",TP_FW,TP_FW);
-	   num_read_chars += sprintf(&(buf[num_read_chars]), "%d error(s). %s\n", error_count, error_count?"":"All test passed.");
-	   return num_read_chars;
-	   }
-
-	//ph = (struct test_header *)(fw->data);
-	 */
+
 READDATA_AGAIN:
 	msleep(30);
 	mutex_lock(&ts->mutex);
@@ -2248,21 +2357,23 @@ READDATA_AGAIN:
 	synaptics_read_register_map_page1(ts);
 	//TPDTM_DMESG("step 1:select report type 0x03\n");
 
-	if(savefile) {
+	if (savefile) {
 		getnstimeofday(&now_time);
 		rtc_time_to_tm(now_time.tv_sec, &rtc_now_time);
 		sprintf(data_buf, "/sdcard/tp_testlimit_%02d%02d%02d-%02d%02d%02d.csv",
-				(rtc_now_time.tm_year+1900)%100, rtc_now_time.tm_mon+1, rtc_now_time.tm_mday,
-				rtc_now_time.tm_hour, rtc_now_time.tm_min, rtc_now_time.tm_sec);
+		        (rtc_now_time.tm_year + 1900) % 100, rtc_now_time.tm_mon + 1, rtc_now_time.tm_mday,
+		        rtc_now_time.tm_hour, rtc_now_time.tm_min, rtc_now_time.tm_sec);
 
 		old_fs = get_fs();
 		set_fs(KERNEL_DS);
 
 		fd = sys_open(data_buf, O_WRONLY | O_CREAT | O_TRUNC, 0);
+
 		if (fd < 0) {
 			TPD_ERR("Open log file '%s' failed.\n", data_buf);
 			set_fs(old_fs);
 		}
+
 		sys_write(fd, "disable cbc", sizeof("disable cbc"));
 		sys_write(fd, "\n", 1);
 	}
@@ -2270,37 +2381,40 @@ READDATA_AGAIN:
 	//step 1:check raw capacitance.
 TEST_WITH_CBC_s3508:
 	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_DATA_BASE, 0x03);//select report type 0x03
-	if( ret < 0 ){
+
+	if (ret < 0) {
 		TPD_ERR("read_baseline: i2c_smbus_write_byte_data failed \n");
 		goto END;
 	}
-	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE+20, 0x01);
-	ret = i2c_smbus_read_byte_data(ts->client,F54_ANALOG_CONTROL_BASE+23);
-	tmp_old = ret&0xff;
 
-	if(enable_cbc){
-		TPD_DEBUG("ret = %x ,tmp_old =%x ,tmp_new = %x\n",ret,tmp_old,(tmp_old | 0x10));
-		ret = i2c_smbus_write_byte_data(ts->client,F54_ANALOG_CONTROL_BASE+23,(tmp_old | 0x10));
-		ret = i2c_smbus_write_word_data(ts->client,F54_ANALOG_COMMAND_BASE,0x04);
+	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 20, 0x01);
+	ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 23);
+	tmp_old = ret & 0xff;
+
+	if (enable_cbc) {
+		TPD_DEBUG("ret = %x ,tmp_old =%x ,tmp_new = %x\n", ret, tmp_old, (tmp_old | 0x10));
+		ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 23, (tmp_old | 0x10));
+		ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_COMMAND_BASE, 0x04);
 		checkCMD();
-		ret = i2c_smbus_read_byte_data(ts->client,F54_ANALOG_CONTROL_BASE+27);
+		ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 27);
 		tmp_new = ret | 0x20;
-		i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE+27, tmp_new);
+		i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 27, tmp_new);
 		ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_COMMAND_BASE, 0x04);
 		TPD_DEBUG("Test open cbc\n");
 		baseline_data_test = (int16_t *)baseline_cap_data[0];
 
-	}else{
-		TPD_DEBUG("ret = %x ,tmp_old =%x ,tmp_new = %x\n",ret,tmp_old,(tmp_old & 0xef));
-		ret = i2c_smbus_write_byte_data(ts->client,F54_ANALOG_CONTROL_BASE+23,(tmp_old & 0xef));
+	} else {
+		TPD_DEBUG("ret = %x ,tmp_old =%x ,tmp_new = %x\n", ret, tmp_old, (tmp_old & 0xef));
+		ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 23, (tmp_old & 0xef));
 		ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_COMMAND_BASE, 0x04);
-		ret = i2c_smbus_read_byte_data(ts->client,F54_ANALOG_CONTROL_BASE+27);
+		ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 27);
 		tmp_new = ret & 0xdf;
-		i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE+27, tmp_new);
+		i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 27, tmp_new);
 		ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_COMMAND_BASE, 0x04); // force update
-		ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE+7, 0x01);// Forbid NoiseMitigation
+		ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 7, 0x01); // Forbid NoiseMitigation
 		baseline_data_test = (int16_t *)baseline_cap_data[1];
 	}
+
 	/******write No Relax to 1******/
 	ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_COMMAND_BASE, 0x04); // force update
 	checkCMD();
@@ -2308,107 +2422,105 @@ TEST_WITH_CBC_s3508:
 	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_COMMAND_BASE, 0X02);//force Cal
 	checkCMD();
 	TPD_DEBUG("Force Cal oK\n");
-	ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_DATA_BASE+1, 0x00);//set fifo 00
+	ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_DATA_BASE + 1, 0x00); //set fifo 00
 	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_COMMAND_BASE, 0x01);//get report
 	checkCMD();
 
 	count = 0;
-	for( x = 0; x < TX_NUM; x++ ){
-
-		for( y = 0; y < RX_NUM; y++ ){
-			ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_DATA_BASE+3);
-			tmp_l = ret&0xff;
-			ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_DATA_BASE+3);
-			tmp_h = ret&0xff;
-			baseline_data = (tmp_h<<8)|tmp_l;
-			if (fd >= 0){
+
+	for (x = 0; x < TX_NUM; x++) {
+
+		for (y = 0; y < RX_NUM; y++) {
+			ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_DATA_BASE + 3);
+			tmp_l = ret & 0xff;
+			ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_DATA_BASE + 3);
+			tmp_h = ret & 0xff;
+			baseline_data = (tmp_h << 8) | tmp_l;
+
+			if (fd >= 0) {
 				sprintf(data_buf, "%d,", baseline_data);
 				sys_write(fd, data_buf, strlen(data_buf));
 			}
-			if( (y < RX_NUM ) && (x < TX_NUM) ){
+
+			if ((y < RX_NUM) && (x < TX_NUM)) {
 				//printk("%4d ,",baseline_data);
-				if (x == (TX_NUM-1) && y == (RX_NUM-1))
+				if (x == (TX_NUM - 1) && y == (RX_NUM - 1))
 					left_ramdata = baseline_data;
-				else if (x == (TX_NUM-1) && y == (RX_NUM-2))
+				else if (x == (TX_NUM - 1) && y == (RX_NUM - 2))
 					right_ramdata = baseline_data;
-				if(((baseline_data+60) < *(baseline_data_test+count*2)) || ((baseline_data-60) > *(baseline_data_test+count*2+1))){
-					if((x == (TX_NUM-1) && (y != RX_NUM-1 || y != RX_NUM-2))||\
-						(x != (TX_NUM-1) && (y == RX_NUM-1 || y == RX_NUM-2)))//the last tx and rx last two line for touchkey,others no need take care
-					{
+
+				if (((baseline_data + 60) < * (baseline_data_test + count * 2)) || ((baseline_data - 60) > *(baseline_data_test + count * 2 + 1))) {
+					if ((x == (TX_NUM - 1) && (y != RX_NUM - 1 || y != RX_NUM - 2)) || \
+					        (x != (TX_NUM - 1) && (y == RX_NUM - 1 || y == RX_NUM - 2))) { //the last tx and rx last two line for touchkey,others no need take care
 						count++;
 						continue;
 					}
-					TPD_ERR("touchpanel failed,RX_NUM:%d,TX_NUM:%d,baseline_data is %d,TPK_array_limit[%d*2]=%d,TPK_array_limit[%d*2+1]=%d\n ",y,x,baseline_data,count,*(baseline_data_test+count*2),count,*(baseline_data_test+count*2+1));
-					if((baseline_data <= 0) && (first_check == 0)){
+
+					TPD_ERR("touchpanel failed,RX_NUM:%d,TX_NUM:%d,baseline_data is %d,TPK_array_limit[%d*2]=%d,TPK_array_limit[%d*2+1]=%d\n ", y, x, baseline_data, count, *(baseline_data_test + count * 2), count, *(baseline_data_test + count * 2 + 1));
+
+					if ((baseline_data <= 0) && (first_check == 0)) {
 						first_check = 1;
 						readdata_fail = 1;
 					}
-					num_read_chars += sprintf(&(buf[num_read_chars]), "0 raw data erro baseline_data[%d][%d]=%d[%d,%d]\n",x,y,baseline_data,*(baseline_data_test+count*2),	*(baseline_data_test+count*2+1));
+
+					num_read_chars += sprintf(&(buf[num_read_chars]), "0 raw data erro baseline_data[%d][%d]=%d[%d,%d]\n", x, y, baseline_data, *(baseline_data_test + count * 2),	*(baseline_data_test + count * 2 + 1));
 					error_count++;
 					goto END;
 				}
 			}
-			/*
-			//test virtual key
-			if( (y==(RX_NUM-1)) && (x>= TX_NUM-3) ){
-			TPD_DEBUG("synaptics:test virtual key,y= %d ,x = %d\n",y,x);
-			TPD_DEBUG("Synaptic:test virtual key;baseline_data is %d,TPK_array_limit[%d*2]=%d,TPK_array_limit[%d*2+1]=%d\n ",baseline_data,count,*(baseline_data_test+count*2),count,*(baseline_data_test+count*2+1));
-			if((baseline_data < *(baseline_data_test+count*2)) || (baseline_data > *(baseline_data_test+count*2+1))){
-			TPD_ERR("Synaptic:test virtual key failed------------;baseline_data is %d,TPK_array_limit[%d*2]=%d,TPK_array_limit[%d*2+1]=%d\n ",baseline_data,count,*(baseline_data_test+count*2),count,*(baseline_data_test+count*2+1));
-			num_read_chars += sprintf(&(buf[num_read_chars]), "0 raw data erro baseline_data[%d][%d]=%d[%d,%d]\n",x,y,baseline_data,*(baseline_data_test+count*2),	*(baseline_data_test+count*2+1));
-			error_count++;
-			goto END;
-			}
-			}
-			 */
+
 			count++;
 		}
-		//printk("\n synaptics:s3320 TX_NUM:%d\n",x);
-		if (fd >= 0){
+
+		if (fd >= 0) {
 			sys_write(fd, "\n", 1);
 		}
 	}
 
-	if(!enable_cbc){
+	if (!enable_cbc) {
 		enable_cbc = 1;
-		if (fd >= 0){
+
+		if (fd >= 0) {
 			sys_write(fd, "enable cbc", sizeof("enable cbc"));
 			sys_write(fd, "\n", 1);
 		}
+
 		TPD_ERR("enable cbc baseline test again\n");
 		goto TEST_WITH_CBC_s3508;
 	}
 
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x1);
-	if( ret < 0 ) {
-		TPD_ERR("%s line%d failed\n",__func__,__LINE__);
+
+	if (ret < 0) {
+		TPD_ERR("%s line%d failed\n", __func__, __LINE__);
 		error_count++;
 		goto END;
 	}
 
 	//Step2 : Check trx-to-ground
-	TPD_ERR("step 2:Check trx-to-ground\n" );
+	TPD_ERR("step 2:Check trx-to-ground\n");
 	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_DATA_BASE, 0x19);//select report type 25
-	ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_DATA_BASE+1, 0x0);
+	ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_DATA_BASE + 1, 0x0);
 	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_COMMAND_BASE, 0x01);//get report
 	checkCMD();
-	tx_datal = i2c_smbus_read_i2c_block_data(ts->client, F54_ANALOG_DATA_BASE+3, 7, buffer);
-    buffer[0]|=0x10;//no care 4 31 32 40 50 51 52chanel
-    buffer[3]|=0x80;
-    buffer[5]|=0x01;
-    buffer[6]|=0xc0;
-	for(x = 0;x < 7; x++)
-	{
-		if(0xff != buffer[x]){
+	tx_datal = i2c_smbus_read_i2c_block_data(ts->client, F54_ANALOG_DATA_BASE + 3, 7, buffer);
+	buffer[0] |= 0x10; //no care 4 31 32 40 50 51 52chanel
+	buffer[3] |= 0x80;
+	buffer[5] |= 0x01;
+	buffer[6] |= 0xc0;
+
+	for (x = 0; x < 7; x++) {
+		if (0xff != buffer[x]) {
 			error_count++;
-            TPD_ERR("step 2:error_count[%d] buff%d[0x%x] ERROR!\n",error_count,x,buffer[x]);
+			TPD_ERR("step 2:error_count[%d] buff%d[0x%x] ERROR!\n", error_count, x, buffer[x]);
 			goto END;
 		}
 	}
 
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x0);
-	if( ret < 0 ) {
-		TPD_ERR("%s line%d failed\n",__func__,__LINE__);
+
+	if (ret < 0) {
+		TPD_ERR("%s line%d failed\n", __func__, __LINE__);
 		error_count++;
 		goto END;
 	}
@@ -2416,35 +2528,37 @@ TEST_WITH_CBC_s3508:
 	ret = i2c_smbus_write_byte_data(ts->client, F01_RMI_CMD_BASE, 0x01);//software reset TP
 	msleep(50);
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x1);
-	if( ret < 0 ) {
-		TPD_ERR("%s line%d failed\n",__func__,__LINE__);
+
+	if (ret < 0) {
+		TPD_ERR("%s line%d failed\n", __func__, __LINE__);
 		error_count++;
 		goto END;
 	}
 
 	//step 3 :check tx-to-tx and tx-to-vdd
-	TPD_ERR("step 3:check TRx-TRx & TRx-Vdd short\n" );
+	TPD_ERR("step 3:check TRx-TRx & TRx-Vdd short\n");
 	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_DATA_BASE, 0x1A);//select report type 26
-	ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_DATA_BASE+1, 0x0);
+	ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_DATA_BASE + 1, 0x0);
 	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_COMMAND_BASE, 0x01);//get report
 	checkCMD();
-	tx_datal = i2c_smbus_read_i2c_block_data(ts->client, F54_ANALOG_DATA_BASE+3, 7, buffer);
-    buffer[0]&=0xef;//no care 4 31 32 40 50 51 52chanel
-    buffer[3]&=0x7f;
-    buffer[5]&=0xfe;
-    buffer[6]&=0x3f;
-	for(x = 0;x < 7; x++)
-	{
-		if(buffer[x]){
+	tx_datal = i2c_smbus_read_i2c_block_data(ts->client, F54_ANALOG_DATA_BASE + 3, 7, buffer);
+	buffer[0] &= 0xef; //no care 4 31 32 40 50 51 52chanel
+	buffer[3] &= 0x7f;
+	buffer[5] &= 0xfe;
+	buffer[6] &= 0x3f;
+
+	for (x = 0; x < 7; x++) {
+		if (buffer[x]) {
 			error_count++;
-	        TPD_ERR("step 3:error_count[%d] buff%d[0x%x] ERROR!\n",error_count,x,buffer[x]);
+			TPD_ERR("step 3:error_count[%d] buff%d[0x%x] ERROR!\n", error_count, x, buffer[x]);
 			goto END;
 		}
 	}
 
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x0);
-	if( ret < 0 ) {
-		TPD_ERR("%s line%d failed\n",__func__,__LINE__);
+
+	if (ret < 0) {
+		TPD_ERR("%s line%d failed\n", __func__, __LINE__);
 		error_count++;
 		goto END;
 	}
@@ -2452,34 +2566,41 @@ TEST_WITH_CBC_s3508:
 	ret = i2c_smbus_write_byte_data(ts->client, F01_RMI_CMD_BASE, 0x01);//software reset TP
 	msleep(50);
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x1);
-	if( ret < 0 ) {
-		TPD_ERR("%s line%d failed\n",__func__,__LINE__);
+
+	if (ret < 0) {
+		TPD_ERR("%s line%d failed\n", __func__, __LINE__);
 		error_count++;
 		goto END;
 	}
+
 	//Step4 : Check RT133
-	TPD_ERR("step 4:Check RT133\n" );
+	TPD_ERR("step 4:Check RT133\n");
 	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_DATA_BASE, 0x85);//select report type 133
-	ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_DATA_BASE+1, 0x0);//set fifo 0
+	ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_DATA_BASE + 1, 0x0); //set fifo 0
 	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_COMMAND_BASE, 0x01);//get report
 	checkCMD_RT133();
-	for( y = 0; y < RX_NUM; y++ ){
-		ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_DATA_BASE+3);
-		tmp_l = ret&0xff;
-		ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_DATA_BASE+3);
-		tmp_h = ret&0xff;
-		baseline_data = (tmp_h<<8)|tmp_l;
-		if(baseline_data > 100){
+
+	for (y = 0; y < RX_NUM; y++) {
+		ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_DATA_BASE + 3);
+		tmp_l = ret & 0xff;
+		ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_DATA_BASE + 3);
+		tmp_h = ret & 0xff;
+		baseline_data = (tmp_h << 8) | tmp_l;
+
+		if (baseline_data > 100) {
 			error_count++;
-            TPD_ERR("step 4:error_count[%d] baseline_data%d[0x%x] ERROR!\n",error_count,y,baseline_data);
+			TPD_ERR("step 4:error_count[%d] baseline_data%d[0x%x] ERROR!\n", error_count, y, baseline_data);
 			goto END;
 		}
 	}
+
 END:
+
 	if (fd >= 0) {
 		sys_close(fd);
 		set_fs(old_fs);
 	}
+
 	//release_firmware(fw);
 	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_COMMAND_BASE, 0X02);
 	delay_qt_ms(60);
@@ -2496,35 +2617,41 @@ END:
 	TPD_ERR("\n\nstep5 reset and open irq complete\n");
 	mutex_unlock(&ts->mutex);
 #endif
-	if(readdata_fail == 1){
-		TPD_ERR("readdata_fail...try again:%d\n",first_check);
-		readdata_fail =0;
+
+	if (readdata_fail == 1) {
+		TPD_ERR("readdata_fail...try again:%d\n", first_check);
+		readdata_fail = 0;
 		goto READDATA_AGAIN;
 	}
+
 #ifdef ENABLE_TPEDGE_LIMIT
 	synaptics_tpedge_limitfunc();
 #endif
-	TPD_ERR("status...first_check:%d:readdata_fail:%d\n",first_check,readdata_fail);
+	TPD_ERR("status...first_check:%d:readdata_fail:%d\n", first_check, readdata_fail);
 	num_read_chars += sprintf(&(buf[num_read_chars]), "imageid=0x%x,deviceid=0x%x\n", TP_FW, TP_FW);
 	num_read_chars += sprintf(&(buf[num_read_chars]), "left:=%d,right:%d\n", left_ramdata, right_ramdata);
-	num_read_chars += sprintf(&(buf[num_read_chars]), "%d error(s). %s\n", error_count, error_count?"":"All test passed.");
+	num_read_chars += sprintf(&(buf[num_read_chars]), "%d error(s). %s\n", error_count, error_count ? "" : "All test passed.");
 	return num_read_chars;
 }
 
 static ssize_t tp_baseline_show_with_cbc(struct device_driver *ddri, char *buf)
 {
 	int ret = 0;
-	int x,y;
+	int x, y;
 	ssize_t num_read_chars = 0;
-	uint8_t tmp_l = 0,tmp_h = 0;
+	uint8_t tmp_l = 0, tmp_h = 0;
 	uint8_t tmp_old, tmp_new;
 	uint16_t count = 0;
 	struct synaptics_ts_data *ts = ts_g;
-	if(ts->is_suspended == 1)
+
+	if (ts->is_suspended == 1)
 		return count;
-	memset(delta_baseline,0,sizeof(delta_baseline));
-	if(!ts)
+
+	memset(delta_baseline, 0, sizeof(delta_baseline));
+
+	if (!ts)
 		return 0;
+
 	/*disable irq when read data from IC*/
 	touch_disable(ts);
 	mutex_lock(&ts->mutex);
@@ -2532,180 +2659,207 @@ static ssize_t tp_baseline_show_with_cbc(struct device_driver *ddri, char *buf)
 	TPD_DEBUG("\nstep 1:select report type 0x03 baseline\n");
 	//step 1:check raw capacitance.
 
-	ret = synaptics_rmi4_i2c_write_byte(ts->client,F54_ANALOG_DATA_BASE,0x03);//select report type 0x03
+	ret = synaptics_rmi4_i2c_write_byte(ts->client, F54_ANALOG_DATA_BASE, 0x03); //select report type 0x03
+
 	if (ret < 0) {
 		TPDTM_DMESG("step 1: select report type 0x03 failed \n");
 		//return sprintf(buf, "i2c err!");
 	}
 
-	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE+20, 0x01);
-	ret = i2c_smbus_read_byte_data(ts->client,F54_ANALOG_CONTROL_BASE+23);
-	tmp_old = ret&0xff;
-	TPD_DEBUG("ret = %x ,tmp_old =%x ,tmp_new = %x\n",ret,tmp_old,(tmp_old | 0x10));
-	ret = i2c_smbus_write_byte_data(ts->client,F54_ANALOG_CONTROL_BASE+23,(tmp_old | 0x10));
-	ret = i2c_smbus_write_word_data(ts->client,F54_ANALOG_COMMAND_BASE,0x04);
+	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 20, 0x01);
+	ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 23);
+	tmp_old = ret & 0xff;
+	TPD_DEBUG("ret = %x ,tmp_old =%x ,tmp_new = %x\n", ret, tmp_old, (tmp_old | 0x10));
+	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 23, (tmp_old | 0x10));
+	ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_COMMAND_BASE, 0x04);
 	checkCMD();
 	TPD_DEBUG("open CBC oK\n");
-	ret = i2c_smbus_read_byte_data(ts->client,F54_ANALOG_CONTROL_BASE+27);
+	ret = i2c_smbus_read_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 27);
 	tmp_new = ret | 0x20;
-	i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE+27, tmp_new);
+	i2c_smbus_write_byte_data(ts->client, F54_ANALOG_CONTROL_BASE + 27, tmp_new);
 	ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_COMMAND_BASE, 0x04);
 
 
-	ret = synaptics_rmi4_i2c_write_byte(ts->client,F54_ANALOG_COMMAND_BASE,0X04);//force F54_ANALOG_CMD00
+	ret = synaptics_rmi4_i2c_write_byte(ts->client, F54_ANALOG_COMMAND_BASE, 0X04); //force F54_ANALOG_CMD00
 	checkCMD();
 	TPD_DEBUG("forbid Forbid NoiseMitigation oK\n");
 
-	ret = synaptics_rmi4_i2c_write_byte(ts->client,F54_ANALOG_COMMAND_BASE,0X02);//Force Cal, F54_ANALOG_CMD00
+	ret = synaptics_rmi4_i2c_write_byte(ts->client, F54_ANALOG_COMMAND_BASE, 0X02); //Force Cal, F54_ANALOG_CMD00
 	checkCMD();
 	TPDTM_DMESG("Force Cal oK\n");
 
-	ret = synaptics_rmi4_i2c_write_word(ts->client,F54_ANALOG_DATA_BASE+1,0x00);//set fifo 00
-	ret = synaptics_rmi4_i2c_write_byte(ts->client,F54_ANALOG_COMMAND_BASE,0x01);//get report
+	ret = synaptics_rmi4_i2c_write_word(ts->client, F54_ANALOG_DATA_BASE + 1, 0x00); //set fifo 00
+	ret = synaptics_rmi4_i2c_write_byte(ts->client, F54_ANALOG_COMMAND_BASE, 0x01); //get report
 	checkCMD();
 	count = 0;
-	for(x = 0;x < TX_NUM; x++) {
-		TPD_DEBUG("\n[%d]",x);
-		num_read_chars += sprintf(&(buf[num_read_chars]), "\n[%d]",x);
-		for(y = 0; y < RX_NUM; y++){
-			ret = synaptics_rmi4_i2c_read_byte(ts->client,F54_ANALOG_DATA_BASE+3);
-			tmp_l = ret&0xff;
-			ret = synaptics_rmi4_i2c_read_byte(ts->client,F54_ANALOG_DATA_BASE+3);
-			tmp_h = ret&0xff;
-			delta_baseline[x][y] = (tmp_h<<8)|tmp_l;
-			TPD_DEBUG("%d,",delta_baseline[x][y]);
-			num_read_chars += sprintf(&(buf[num_read_chars]), "%d ",delta_baseline[x][y]);
+
+	for (x = 0; x < TX_NUM; x++) {
+		TPD_DEBUG("\n[%d]", x);
+		num_read_chars += sprintf(&(buf[num_read_chars]), "\n[%d]", x);
+
+		for (y = 0; y < RX_NUM; y++) {
+			ret = synaptics_rmi4_i2c_read_byte(ts->client, F54_ANALOG_DATA_BASE + 3);
+			tmp_l = ret & 0xff;
+			ret = synaptics_rmi4_i2c_read_byte(ts->client, F54_ANALOG_DATA_BASE + 3);
+			tmp_h = ret & 0xff;
+			delta_baseline[x][y] = (tmp_h << 8) | tmp_l;
+			TPD_DEBUG("%d,", delta_baseline[x][y]);
+			num_read_chars += sprintf(&(buf[num_read_chars]), "%d ", delta_baseline[x][y]);
 		}
 	}
 
-	ret = synaptics_rmi4_i2c_write_byte(ts->client,F54_ANALOG_COMMAND_BASE,0X02);
+	ret = synaptics_rmi4_i2c_write_byte(ts->client, F54_ANALOG_COMMAND_BASE, 0X02);
 	delay_qt_ms(60);
-	synaptics_enable_interrupt(ts,1);
+	synaptics_enable_interrupt(ts, 1);
 	mutex_unlock(&ts->mutex);
 	touch_enable(ts);
 	return num_read_chars;
 }
 
-static ssize_t synaptics_rmi4_baseline_show(struct device *dev,	char *buf, bool savefile)
+static ssize_t synaptics_rmi4_baseline_show(struct device *dev, char *buf, bool savefile)
 {
-	return synaptics_rmi4_baseline_show_s3508(dev,buf,savefile);
+	return synaptics_rmi4_baseline_show_s3508(dev, buf, savefile);
 }
 
 static ssize_t tp_test_store(struct device_driver *ddri,
-		const char *buf, size_t count)
+                             const char *buf, size_t count)
 {
 	TPDTM_DMESG("tp_test_store is not support\n");
 	return count;
 }
 
 static ssize_t synaptics_rmi4_vendor_id_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
+        struct device_attribute *attr, char *buf)
 {
-	if( (tp_dev == TP_G2Y) || (tp_dev == TP_TPK) )
+	if ((tp_dev == TP_G2Y) || (tp_dev == TP_TPK))
 		return sprintf(buf, "%d\n", TP_TPK);
-	if(tp_dev == TP_TRULY)
+
+	if (tp_dev == TP_TRULY)
 		return sprintf(buf, "%d\n", TP_TRULY);
-	if(tp_dev == TP_OFILM)
+
+	if (tp_dev == TP_OFILM)
 		return sprintf(buf, "%d\n", TP_OFILM);
+
 	return sprintf(buf, "%d\n", tp_dev);
 }
 
-
 static int	synaptics_input_init(struct synaptics_ts_data *ts)
 {
 	int attr_count = 0;
 	int ret = 0;
 
-	TPD_DEBUG("%s is called\n",__func__);
+	TPD_DEBUG("%s is called\n", __func__);
 	ts->input_dev = input_allocate_device();
+
 	if (ts->input_dev == NULL) {
 		ret = -ENOMEM;
 		TPD_ERR("synaptics_ts_probe: Failed to allocate input device\n");
 		return ret;
 	}
-	ts->input_dev->name = TPD_DEVICE;;
+
+	ts->input_dev->name = "synaptics";
 	ts->input_dev->dev.parent = &ts->client->dev;
 	set_bit(EV_SYN, ts->input_dev->evbit);
 	set_bit(EV_ABS, ts->input_dev->evbit);
 	set_bit(EV_KEY, ts->input_dev->evbit);
 	set_bit(ABS_MT_TOUCH_MAJOR, ts->input_dev->absbit);
-	set_bit(ABS_MT_WIDTH_MAJOR,ts->input_dev->absbit);
+	set_bit(ABS_MT_WIDTH_MAJOR, ts->input_dev->absbit);
 	set_bit(ABS_MT_POSITION_X, ts->input_dev->absbit);
 	set_bit(ABS_MT_POSITION_Y, ts->input_dev->absbit);
 	set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
 	set_bit(BTN_TOOL_FINGER, ts->input_dev->keybit);
 #ifdef SUPPORT_GESTURE
-	set_bit(KEY_F4 , ts->input_dev->keybit);//doulbe-tap resume
+	set_bit(KEY_F4, ts->input_dev->keybit); //doulbe-tap resume
 	set_bit(KEY_DOUBLE_TAP, ts->input_dev->keybit);
+	set_bit(KEY_GESTURE_W, ts->input_dev->keybit);
+	set_bit(KEY_GESTURE_M, ts->input_dev->keybit);
+	set_bit(KEY_GESTURE_S, ts->input_dev->keybit);
 	set_bit(KEY_GESTURE_CIRCLE, ts->input_dev->keybit);
-	set_bit(KEY_GESTURE_V, ts->input_dev->keybit);
 	set_bit(KEY_GESTURE_TWO_SWIPE, ts->input_dev->keybit);
-	set_bit(KEY_GESTURE_LEFT_V, ts->input_dev->keybit);
-	set_bit(KEY_GESTURE_RIGHT_V, ts->input_dev->keybit);
-	set_bit(KEY_APPSELECT, ts->input_dev->keybit);
-	set_bit(KEY_BACK, ts->input_dev->keybit);
+	set_bit(KEY_GESTURE_UP_ARROW, ts->input_dev->keybit);
+	set_bit(KEY_GESTURE_LEFT_ARROW, ts->input_dev->keybit);
+	set_bit(KEY_GESTURE_RIGHT_ARROW, ts->input_dev->keybit);
+	set_bit(KEY_GESTURE_DOWN_ARROW, ts->input_dev->keybit);
+	set_bit(KEY_GESTURE_SWIPE_UP, ts->input_dev->keybit);
+	set_bit(KEY_GESTURE_SWIPE_LEFT, ts->input_dev->keybit);
+	set_bit(KEY_GESTURE_SWIPE_RIGHT, ts->input_dev->keybit);
+	set_bit(KEY_GESTURE_SWIPE_DOWN, ts->input_dev->keybit);
 #endif
+	set_bit(KEY_BUTTON_LEFT, ts->input_dev->keybit);
+	set_bit(KEY_BUTTON_RIGHT, ts->input_dev->keybit);
 	/* For multi touch */
 	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MINOR, 0,255, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, (ts->max_x-1), 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, (ts->max_y-1), 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MINOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, (ts->max_x - 1), 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, (ts->max_y - 1), 0, 0);
 #ifdef REPORT_2D_PRESSURE
-    if (ts->support_ft){
-        input_set_abs_params(ts->input_dev,ABS_MT_PRESSURE,0,255, 0, 0);
-    }
+
+	if (ts->support_ft) {
+		input_set_abs_params(ts->input_dev, ABS_MT_PRESSURE, 0, 255, 0, 0);
+	}
+
 #endif
 #ifdef TYPE_B_PROTOCOL
 	input_mt_init_slots(ts->input_dev, ts->max_num, 0);
 #endif
 	input_set_drvdata(ts->input_dev, ts);
 
-	if(input_register_device(ts->input_dev)) {
-		TPD_ERR("%s: Failed to register input device\n",__func__);
+	if (input_register_device(ts->input_dev)) {
+		TPD_ERR("%s: Failed to register input device\n", __func__);
 		input_unregister_device(ts->input_dev);
 		input_free_device(ts->input_dev);
 		return -1;
 	}
+
 	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs_oem); attr_count++) {
 		ret = sysfs_create_file(&ts->input_dev->dev.kobj,
-				&attrs_oem[attr_count].attr);
+		                        &attrs_oem[attr_count].attr);
+
 		if (ret < 0) {
 			dev_err(&ts->client->dev,
-					"%s: Failed to create sysfs attributes\n",
-					__func__);
+			        "%s: Failed to create sysfs attributes\n",
+			        __func__);
+
 			for (attr_count--; attr_count >= 0; attr_count--) {
 				sysfs_remove_file(&ts->input_dev->dev.kobj,
-						&attrs_oem[attr_count].attr);
+				                  &attrs_oem[attr_count].attr);
 			}
+
 			return -1;
 		}
 	}
+
 	return 0;
 }
 
 #include "fw_update_v7.if"
 static int check_hardware_version(struct device *dev)
 {
-        int ret;
+	int ret;
 	struct synaptics_ts_data *ts = dev_get_drvdata(dev);
-        const struct firmware *fw = NULL;
-	if(!ts->client) {
+	const struct firmware *fw = NULL;
+
+	if (!ts->client) {
 		TPD_ERR("i2c client point is NULL\n");
 		return 0;
 	}
+
 	ret = request_firmware(&fw, ts->fw_name, dev);
+
 	if (ret < 0) {
-		TPD_ERR("Request firmware failed - %s (%d)\n",ts->fw_name, ret);
+		TPD_ERR("Request firmware failed - %s (%d)\n", ts->fw_name, ret);
 		return ret;
 	}
 
-        ret = fwu_start_reflash_check(fw->data,ts->client);
+	ret = fwu_start_reflash_check(fw->data, ts->client);
 	release_firmware(fw);
-        if (ret < 0)
+
+	if (ret < 0)
 		return -1;
-        else
-            	return ret;
+	else
+		return ret;
 }
+
 static int check_version = 0;
 /*********************FW Update Func******************************************/
 static int synatpitcs_fw_update(struct device *dev, bool force)
@@ -2715,125 +2869,137 @@ static int synatpitcs_fw_update(struct device *dev, bool force)
 	int ret;
 	char fw_id_temp[12];
 	uint8_t buf[4];
-	uint32_t CURRENT_FIRMWARE_ID = 0 ;
+	uint32_t CURRENT_FIRMWARE_ID = 0;
+
+	static bool check_onetime = true;
 
-        static bool check_onetime = true;
+	TPD_DEBUG("%s is called\n", __func__);
 
-        TPD_DEBUG("%s is called\n",__func__);
-	if(!ts->client) {
+	if (!ts->client) {
 		TPD_ERR("i2c client point is NULL\n");
 		return 0;
 	}
-	if (!strncmp(ts->manu_name,"S3718",5)){
-		if(check_onetime){
+
+	if (!strncmp(ts->manu_name, "S3718", 5)) {
+		if (check_onetime) {
 			check_onetime = false;
 			check_version = check_hardware_version(dev);
-			TPD_ERR("%s:first check hardware version %d\n",__func__,check_version);
-			if(check_version < 0){
+			TPD_ERR("%s:first check hardware version %d\n", __func__, check_version);
+
+			if (check_version < 0) {
 				TPD_ERR("checkversion fail....\n");
 				return -1;
 			}
 		}
 
-		if(1 == check_version ) {
+		if (1 == check_version) {
 			TPD_DEBUG("enter version 15801 update mode\n");
-			strcpy(ts->fw_name,"tp/fw_synaptics_15801.img");
+			strcpy(ts->fw_name, "tp/fw_synaptics_15801.img");
 			//push_component_info(TP, ts->fw_id, "S3718_vA");
 			ret = request_firmware(&fw, ts->fw_name, dev);
+
 			if (ret < 0) {
-				TPD_ERR("Request firmware failed - %s (%d)\n",ts->fw_name, ret);
+				TPD_ERR("Request firmware failed - %s (%d)\n", ts->fw_name, ret);
 				return ret;
-		       }
+			}
 
-		 }else{
-		        TPD_DEBUG("enter version 15801 vb update mode\n");
+		} else {
+			TPD_DEBUG("enter version 15801 vb update mode\n");
 			//push_component_info(TP, ts->fw_id, "S3718_vB");
 			ret = request_firmware(&fw, ts->fw_name, dev);
+
 			if (ret < 0) {
-				TPD_ERR("Request firmware failed - %s (%d)\n",ts->fw_name, ret);
+				TPD_ERR("Request firmware failed - %s (%d)\n", ts->fw_name, ret);
 				return ret;
-		       }
+			}
 		}
 
-	}else if(!strncmp(ts->manu_name,"s3508",5) || !strncmp(ts->manu_name,"15811",5)){
-		        TPD_ERR("enter version 16859 update mode\n");
-			//push_component_info(TP, ts->fw_id, "s3508");
-			ret = request_firmware(&fw, ts->fw_name, dev);
-			if (ret < 0) {
-				TPD_ERR("Request firmware failed - %s (%d)\n",ts->fw_name, ret);
-				return ret;
-		       }
-	}else{
+	} else if (!strncmp(ts->manu_name, "s3508", 5) || !strncmp(ts->manu_name, "15811", 5)) {
+		TPD_ERR("enter version 16859 update mode\n");
+		//push_component_info(TP, ts->fw_id, "s3508");
+		ret = request_firmware(&fw, ts->fw_name, dev);
+
+		if (ret < 0) {
+			TPD_ERR("Request firmware failed - %s (%d)\n", ts->fw_name, ret);
+			return ret;
+		}
+	} else {
 		TPD_ERR("firmware name not match\n");
 		return -1;
 	}
 
 	ret = synapitcs_ts_update(ts->client, fw->data, fw->size, force);
-	if(ret < 0){
+
+	if (ret < 0) {
 		TPD_ERR("FW update not success try again\n");
 		ret = synapitcs_ts_update(ts->client, fw->data, fw->size, force);
-		if(ret < 0){
+
+		if (ret < 0) {
 			TPD_ERR("FW update failed twice, quit updating process!\n");
 			return ret;
 		}
 	}
+
 	release_firmware(fw);
 
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x0);
 	ret = synaptics_rmi4_i2c_read_block(ts->client, F34_FLASH_CTRL00, 4, buf);
-	CURRENT_FIRMWARE_ID = (buf[0]<<24)|(buf[1]<<16)|(buf[2]<<8)|buf[3];
-	sprintf(fw_id_temp,"0x%x",CURRENT_FIRMWARE_ID);
-	strcpy(ts->fw_id,fw_id_temp);
+	CURRENT_FIRMWARE_ID = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
+	sprintf(fw_id_temp, "0x%x", CURRENT_FIRMWARE_ID);
+	strcpy(ts->fw_id, fw_id_temp);
 	TP_FW = CURRENT_FIRMWARE_ID;
-	report_key_point_y = ts->max_y*button_map[2]/LCD_HEIGHT;
+	report_key_point_y = ts->max_y * button_map[2] / LCD_HEIGHT;
 #ifdef SUPPORT_GLOVES_MODE
 	synaptics_glove_mode_enable(ts);
 #endif
 	synaptics_init_panel(ts);
-	synaptics_enable_interrupt(ts,1);
+	synaptics_enable_interrupt(ts, 1);
 	return 0;
 }
 
 static ssize_t synaptics_update_fw_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
+                                        struct device_attribute *attr, char *buf)
 {
 	struct synaptics_ts_data *data = dev_get_drvdata(dev);
 	return snprintf(buf, 2, "%d\n", data->loading_fw);
 }
 
 static ssize_t synaptics_update_fw_store(struct device *dev,
-		struct device_attribute *attr,
-		const char *buf, size_t size)
+        struct device_attribute *attr,
+        const char *buf, size_t size)
 {
 	struct synaptics_ts_data *ts = dev_get_drvdata(dev);
 	unsigned long val;
 	int rc;
 
-	if (ts->is_suspended && ts->support_hw_poweroff){
+	if (ts->is_suspended && ts->support_hw_poweroff) {
 		TPD_ERR("power off firmware abort!\n");
 		return size;
 	}
-	if(version_is_s3508){
-		if (strncmp(ts->manu_name,"s3508",5) && strncmp(ts->manu_name,"15811",5)){
-        		TPD_ERR("product name[%s] do not update!\n",ts->manu_name);
-        		return size;
-   		 }
-	}else{
-    		if (strncmp(ts->manu_name,"S3718",5)){
-        		TPD_ERR("product name[%s] do not update!\n",ts->manu_name);
-        		return size;
-   		 }
+
+	if (version_is_s3508) {
+		if (strncmp(ts->manu_name, "s3508", 5) && strncmp(ts->manu_name, "15811", 5)) {
+			TPD_ERR("product name[%s] do not update!\n", ts->manu_name);
+			return size;
+		}
+	} else {
+		if (strncmp(ts->manu_name, "S3718", 5)) {
+			TPD_ERR("product name[%s] do not update!\n", ts->manu_name);
+			return size;
+		}
 	}
-	TPD_ERR("start update ******* fw_name:%s,ts->manu_name:%s\n",ts->fw_name,ts->manu_name);
+
+	TPD_ERR("start update ******* fw_name:%s,ts->manu_name:%s\n", ts->fw_name, ts->manu_name);
 
 	if (size > 2)
 		return -EINVAL;
 
 	rc = kstrtoul(buf, 10, &val);
+
 	if (rc != 0)
 		return rc;
 
-	if(!val)
+	if (!val)
 		val = force_update;
 
 	touch_disable(ts);
@@ -2848,9 +3014,8 @@ static ssize_t synaptics_update_fw_store(struct device *dev,
 }
 /*********************FW Update Func End*************************************/
 
-
 static ssize_t synaptics_test_limit_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
+        struct device_attribute *attr, char *buf)
 {
 	struct synaptics_ts_data *ts = dev_get_drvdata(dev);
 	int ret = 0;
@@ -2862,10 +3027,11 @@ static ssize_t synaptics_test_limit_show(struct device *dev,
 	int temp = 0;
 	static int cat_cbc_change = 0;
 	ret = request_firmware(&fw, ts->test_limit_name, dev);
+
 	if (ret < 0) {
 		TPD_ERR("Request firmware failed - %s (%d)\n",
-				ts->test_limit_name, ret);
-		temp = temp + sprintf(&buf[temp],"Request failed,Check the path %d",temp);
+		        ts->test_limit_name, ret);
+		temp = temp + sprintf(&buf[temp], "Request failed,Check the path %d", temp);
 		return temp;
 	}
 
@@ -2875,38 +3041,46 @@ static ssize_t synaptics_test_limit_show(struct device *dev,
 	prowcbc = (uint16_t *)(fw->data + ph->array_limitcbc_offset);
 
 	TPD_DEBUG("synaptics_test_limit_show:array_limit_offset = %x array_limitcbc_offset = %x\n",
-			ph->array_limit_offset,ph->array_limitcbc_offset);
+	          ph->array_limit_offset, ph->array_limitcbc_offset);
 
 	TPD_DEBUG("test begin:\n");
-	if(cat_cbc_change == 0 || ph->withCBC == 0) {
+
+	if (cat_cbc_change == 0 || ph->withCBC == 0) {
 		temp += sprintf(buf, "Without cbc:");
-		for(i = 0 ;i < (ph->array_limit_size/2 ); i++){
-			if(i % (2*RX_NUM) == 0)
-				temp += sprintf(&(buf[temp]), "\n[%d] ",(i/RX_NUM)/2);
-			temp += sprintf(&buf[temp],"%d,",prow[i]);
-			printk("%d,",prow[i]);
+
+		for (i = 0; i < (ph->array_limit_size / 2); i++) {
+			if (i % (2 * RX_NUM) == 0)
+				temp += sprintf(&(buf[temp]), "\n[%d] ", (i / RX_NUM) / 2);
+
+			temp += sprintf(&buf[temp], "%d,", prow[i]);
+			printk("%d,", prow[i]);
 		}
+
 		cat_cbc_change = 1;
-	}else{
+	} else {
 		temp += sprintf(buf, "With cbc:");
 		cat_cbc_change = 0;
-		if( ph->withCBC == 0){
+
+		if (ph->withCBC == 0) {
 			return temp;
 		}
-		for(i = 0 ;i < (ph->array_limitcbc_size/2 ); i++){
-			if(i % (2*RX_NUM) == 0)
-				temp += sprintf(&(buf[temp]), "\n[%d] ",(i/RX_NUM)/2);
-			temp += sprintf(&buf[temp],"%d,",prowcbc[i]);
-			printk("%d,",prowcbc[i]);
+
+		for (i = 0; i < (ph->array_limitcbc_size / 2); i++) {
+			if (i % (2 * RX_NUM) == 0)
+				temp += sprintf(&(buf[temp]), "\n[%d] ", (i / RX_NUM) / 2);
+
+			temp += sprintf(&buf[temp], "%d,", prowcbc[i]);
+			printk("%d,", prowcbc[i]);
 		}
 	}
+
 	release_firmware(fw);
 	return temp;
 }
 
 static ssize_t synaptics_test_limit_store(struct device *dev,
-		struct device_attribute *attr,
-		const char *buf, size_t size)
+        struct device_attribute *attr,
+        const char *buf, size_t size)
 {
 	return size;
 }
@@ -2920,82 +3094,68 @@ static DRIVER_ATTR(tp_debug_log, 0664, tp_show, store_tp);
 static DEVICE_ATTR(tp_fw_update, 0664, synaptics_update_fw_show, synaptics_update_fw_store);
 static int synaptics_dsx_pinctrl_init(struct synaptics_ts_data *ts);
 
-static ssize_t tp_reset_write_func (struct file *file, const char *buffer, size_t count, loff_t *ppos)
+static ssize_t tp_reset_write_func(struct file *file, const char *buffer, size_t count, loff_t *ppos)
 {
-    int ret,write_flag,i;
+	int ret, write_flag, i;
 	struct synaptics_ts_data *ts = ts_g;
 
-	if(ts->loading_fw) {
-		TPD_ERR("%s FW is updating break!!\n",__func__);
+	if (ts->loading_fw) {
+		TPD_ERR("%s FW is updating break!!\n", __func__);
 		return count;
 	}
 
-	ret = sscanf(buffer,"%x",&write_flag);
-	TPD_ERR("%s write [%d]\n",__func__,write_flag);
-	if (1 == write_flag)
-	{
+	ret = sscanf(buffer, "%x", &write_flag);
+	TPD_ERR("%s write [%d]\n", __func__, write_flag);
+
+	if (1 == write_flag) {
 		ret = synaptics_soft_reset(ts);
-	}
-	else if(2 == write_flag)
-	{
+	} else if (2 == write_flag) {
 		synaptics_hard_reset(ts);
-	}
-	else if(3 == write_flag)
-	{
+	} else if (3 == write_flag) {
 		disable_irq_nosync(ts->irq);
-	}
-	else if(4 == write_flag)
-	{
+	} else if (4 == write_flag) {
 		enable_irq(ts->irq);
-	}
-	else if(8 == write_flag)
-	{
+	} else if (8 == write_flag) {
 		touch_enable(ts);
-	}
-	else if(9 == write_flag)
-	{
+	} else if (9 == write_flag) {
 		touch_disable(ts);
-	}
-	else if(5 == write_flag)
-	{
+	} else if (5 == write_flag) {
 		synaptics_read_register_map(ts);
-	}
-	else if(6 == write_flag)
-	{
-		for (i = 0; i < ts->max_num; i++)
-		{
+	} else if (6 == write_flag) {
+		for (i = 0; i < ts->max_num; i++) {
 			input_mt_slot(ts->input_dev, i);
 			input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 1);
 			input_mt_slot(ts->input_dev, i);
 			input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 0);
 		}
-		#ifndef TYPE_B_PROTOCOL
+
+#ifndef TYPE_B_PROTOCOL
 		input_mt_sync(ts->input_dev);
-		#endif
+#endif
 		input_report_key(ts->input_dev, BTN_TOOL_FINGER, 0);
 		input_sync(ts->input_dev);
 	}
+
 	return count;
 }
 
 //chenggang.li@bsp add for 14045
-static const struct file_operations base_register_address= {
+static const struct file_operations radd_proc_fops = {
 	.write = synap_write_address,
 	.read =  synap_read_address,
 	.open = simple_open,
 	.owner = THIS_MODULE,
 };
 
-
 //wangwenxue@BSP add for change baseline_test to "proc\touchpanel\baseline_test"  begin
-static const struct file_operations i2c_device_test_fops = {
+static const struct file_operations i2c_device_test_proc_fops = {
 	.read =  i2c_device_test_read_func,
 	.open = simple_open,
 	.owner = THIS_MODULE,
 };
 
 //wangwenxue@BSP add for change baseline_test to "proc\touchpanel\baseline_test"  begin
-static const struct file_operations tp_baseline_test_proc_fops = {
+static const struct file_operations baseline_test_proc_fops = {
 	.read =  tp_baseline_test_read_func,
 	.open = simple_open,
 	.owner = THIS_MODULE,
@@ -3024,57 +3184,69 @@ static const struct file_operations tp_reset_proc_fops = {
 	.open = simple_open,
 	.owner = THIS_MODULE,
 };
+
 static const struct file_operations vendor_id_proc_fops = {
 	.read =  vendor_id_read_func,
 	.open = simple_open,
 	.owner = THIS_MODULE,
 };
+
 static int set_changer_bit(struct synaptics_ts_data *ts)
 {
-    int mode;
-    int ret;
-    mode = i2c_smbus_read_byte_data(ts_g->client, F01_RMI_CTRL00);
-    if (ts->changer_connet)
-        mode = mode | 0x20;
-    else
-        mode = mode & 0xDF;
-    ret = i2c_smbus_write_byte_data(ts_g->client, F01_RMI_CTRL00, mode);
-    return ret;
+	int mode;
+	int ret;
+	mode = i2c_smbus_read_byte_data(ts_g->client, F01_RMI_CTRL00);
+
+	if (ts->changer_connet)
+		mode = mode | 0x20;
+	else
+		mode = mode & 0xDF;
+
+	ret = i2c_smbus_write_byte_data(ts_g->client, F01_RMI_CTRL00, mode);
+	return ret;
 }
+
 static ssize_t changer_read_func(struct file *file, char __user *user_buf, size_t count, loff_t *ppos)
 {
 	int ret = 0;
 	char page[PAGESIZE];
 	struct synaptics_ts_data *ts = ts_g;
-	if(!ts)
+
+	if (!ts)
 		return ret;
-	ret = sprintf(page, "the changer is %s!\n", ts->changer_connet?("conneted"):("disconneted"));
+
+	ret = sprintf(page, "the changer is %s!\n", ts->changer_connet ? ("conneted") : ("disconneted"));
 	ret = simple_read_from_buffer(user_buf, count, ppos, page, strlen(page));
 	return ret;
 }
 
 static ssize_t changer_write_func(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
 {
-	struct synaptics_ts_data *ts= ts_g;
-	int ret = 0 ;
+	struct synaptics_ts_data *ts = ts_g;
+	int ret = 0;
 
 	sscanf(&buffer[0], "%d", &ret);
-	if(!ts)
+
+	if (!ts)
 		return count;
-	if( (ret == 0 ) || (ret == 1) ){
+
+	if ((ret == 0) || (ret == 1)) {
 		ts->changer_connet = ret;
-        ret = set_changer_bit(ts);
+		ret = set_changer_bit(ts);
 	}
-	TPDTM_DMESG("%s:ts->changer_connet = %d\n",__func__,ts->changer_connet);
+
+	TPDTM_DMESG("%s:ts->changer_connet = %d\n", __func__, ts->changer_connet);
 	return count;
 }
-static const struct file_operations changer_ops = {
+
+static const struct file_operations changer_connet_proc_fops = {
 	.write = changer_write_func,
 	.read =  changer_read_func,
 	.open = simple_open,
 	.owner = THIS_MODULE,
 };
-#define SUBABS(x,y) ((x)-(y))
+
+#define SUBABS(x, y) ((x)-(y))
 static int tp_baseline_get(struct synaptics_ts_data *ts, bool flag)
 {
 	int ret = 0;
@@ -3082,56 +3254,61 @@ static int tp_baseline_get(struct synaptics_ts_data *ts, bool flag)
 	uint8_t *value;
 	int k = 0;
 
-	if(!ts)
+	if (!ts)
 		return -1;
 
-	atomic_set(&ts->is_stop,1);
+	atomic_set(&ts->is_stop, 1);
 	touch_disable(ts);
-	TPD_DEBUG("%s start!\n",__func__);
-	value = kzalloc(TX_NUM*RX_NUM*2, GFP_KERNEL);
-	memset(delta_baseline,0,sizeof(delta_baseline));
+	TPD_DEBUG("%s start!\n", __func__);
+	value = kzalloc(TX_NUM * RX_NUM * 2, GFP_KERNEL);
+	memset(delta_baseline, 0, sizeof(delta_baseline));
 
 	mutex_lock(&ts->mutex);
-	if (ts->gesture_enable)
-		synaptics_enable_interrupt_for_gesture(ts,false);
+
+	if (ts->gestures_enable != 0)
+		synaptics_enable_interrupt_for_gesture(ts, false);
 	else
 		synaptics_mode_change(0x00);//change to active later getbase data
+
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x1);
 
 	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_DATA_BASE, 0x03);//select report type 0x03
-	ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_DATA_BASE+1, 0);//set fifo 00
+	ret = i2c_smbus_write_word_data(ts->client, F54_ANALOG_DATA_BASE + 1, 0); //set fifo 00
 	ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_COMMAND_BASE, 0x01);//get report
 	checkCMD();
 
-	ret = synaptics_rmi4_i2c_read_block(ts->client,F54_ANALOG_DATA_BASE+3,2*TX_NUM*RX_NUM,value);
-	for( x = 0; x < TX_NUM; x++ ){
-		for( y = 0; y < RX_NUM; y++ ){
-			delta_baseline[x][y] =  (int16_t)(((uint16_t)( value [k])) | ((uint16_t)( value [k+1] << 8)));
+	ret = synaptics_rmi4_i2c_read_block(ts->client, F54_ANALOG_DATA_BASE + 3, 2 * TX_NUM * RX_NUM, value);
+
+	for (x = 0; x < TX_NUM; x++) {
+		for (y = 0; y < RX_NUM; y++) {
+			delta_baseline[x][y] = (int16_t)(((uint16_t)(value [k])) | ((uint16_t)(value [k + 1] << 8)));
 			k = k + 2;
 
 			if (flag)
-				delta[x][y] = SUBABS(delta_baseline[x][y],baseline[x][y]);
+				delta[x][y] = SUBABS(delta_baseline[x][y], baseline[x][y]);
 			else
 				baseline[x][y] = delta_baseline[x][y];
 		}
 	}
-        //ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_COMMAND_BASE, 0X02);
+
+	//ret = i2c_smbus_write_byte_data(ts->client, F54_ANALOG_COMMAND_BASE, 0X02);
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x0);
 	ret = i2c_smbus_write_byte_data(ts->client, F01_RMI_CMD_BASE, 0x01);//soft reset
 	mutex_unlock(&ts->mutex);
-	atomic_set(&ts->is_stop,0);
+	atomic_set(&ts->is_stop, 0);
 	msleep(2);
 	touch_enable(ts);
 #ifdef ENABLE_TPEDGE_LIMIT
 	synaptics_tpedge_limitfunc();
 #endif
-	TPD_DEBUG("%s end! \n",__func__);
+	TPD_DEBUG("%s end! \n", __func__);
 	kfree(value);
 	return 0;
 }
+
 static void tp_baseline_get_work(struct work_struct *work)
 {
-	struct synaptics_ts_data *ts= ts_g;
+	struct synaptics_ts_data *ts = ts_g;
 
 	tp_baseline_get(ts, true);//get the delta data
 }
@@ -3139,37 +3316,41 @@ static void tp_baseline_get_work(struct work_struct *work)
 static ssize_t touch_press_status_read(struct file *file, char __user *user_buf, size_t count, loff_t *ppos)
 {
 	int ret = 0;
-	int x,y;
+	int x, y;
 	int press_points = 0;
-	int points_misspresee =0;
+	int points_misspresee = 0;
 	int str_n = 0;
 
-	char *page = kzalloc(1024*2,GFP_KERNEL);
-	if (!page){
-		TPD_ERR("%s malloc memery error!",__func__);
+	char *page = kzalloc(1024 * 2, GFP_KERNEL);
+
+	if (!page) {
+		TPD_ERR("%s malloc memery error!", __func__);
 		return -ENOMEM;
 	}
-	TPD_ERR("%s",__func__);
 
-	for (x = 0; x < TX_NUMBER; x++){
-		for (y = 0; y < RX_NUMBER; y++){
-			if (x > (TX_NUMBER-1) || y < (RX_NUMBER-12) )//exclude the key tx and upper part
+	TPD_ERR("%s", __func__);
+
+	for (x = 0; x < TX_NUMBER; x++) {
+		for (y = 0; y < RX_NUMBER; y++) {
+			if (x > (TX_NUMBER - 1) || y < (RX_NUMBER - 12)) //exclude the key tx and upper part
 				continue;
-			if ((delta[x][y] < -30) && (delta[x][y] > -250))
-			{
+
+			if ((delta[x][y] < -30) && (delta[x][y] > -250)) {
 				//str_n += sprintf(&page[str_n],"x%d,y%d = %4d\n", x, y, delta[x][y]);
 				press_points++;
 			}
-			if((delta[x][y] > 30) && (delta[x][y] < 200))
+
+			if ((delta[x][y] > 30) && (delta[x][y] < 200))
 				points_misspresee ++;
 		}
 
 	}
 
-	if(points_misspresee > 4)
+	if (points_misspresee > 4)
 		get_tp_base = 0;
-	TPD_ERR("points_mispressee num:%d,get_tp_base:%d\n",points_misspresee,get_tp_base);
-	str_n += sprintf(&page[str_n], "\n%s %d points delta > [25]\n",(press_points>4)?"near":"away", press_points);
+
+	TPD_ERR("points_mispressee num:%d,get_tp_base:%d\n", points_misspresee, get_tp_base);
+	str_n += sprintf(&page[str_n], "\n%s %d points delta > [25]\n", (press_points > 4) ? "near" : "away", press_points);
 	ret = simple_read_from_buffer(user_buf, count, ppos, page, strlen(page));
 	kfree(page);
 	return ret;
@@ -3177,26 +3358,29 @@ static ssize_t touch_press_status_read(struct file *file, char __user *user_buf,
 
 static ssize_t touch_press_status_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
 {
-	struct synaptics_ts_data *ts= ts_g;
-	int ret = 0 ;
+	struct synaptics_ts_data *ts = ts_g;
+	int ret = 0;
 
 	sscanf(&buffer[0], "%d", &ret);
-	if(!ts)
+
+	if (!ts)
 		return count;
 
-	TPD_ERR("%s write %d\n",__func__,ret);
-	if (ret == 0){
-		tp_baseline_get(ts,false);
-	}
-	else if(ret == 1) {
-		if (0 == ts->gesture_enable)
-			queue_delayed_work(get_base_report, &ts->base_work,msecs_to_jiffies(120));
+	TPD_ERR("%s write %d\n", __func__, ret);
+
+	if (ret == 0) {
+		tp_baseline_get(ts, false);
+	} else if (ret == 1) {
+		if (ts->gestures_enable == 0)
+			queue_delayed_work(get_base_report, &ts->base_work, msecs_to_jiffies(120));
 		else
-			queue_delayed_work(get_base_report, &ts->base_work,msecs_to_jiffies(1));
+			queue_delayed_work(get_base_report, &ts->base_work, msecs_to_jiffies(1));
 	}
+
 	return count;
 }
-static const struct file_operations touch_press_status = {
+
+static const struct file_operations touch_press_proc_fops = {
 	.write = touch_press_status_write,
 	.read =  touch_press_status_read,
 	.open = simple_open,
@@ -3206,7 +3390,7 @@ static const struct file_operations touch_press_status = {
 #ifdef ENABLE_TPEDGE_LIMIT
 static ssize_t limit_enable_read(struct file *file, char __user *user_buf, size_t count, loff_t *ppos)
 {
-	ssize_t ret =0;
+	ssize_t ret = 0;
 	char page[PAGESIZE];
 
 	TPD_DEBUG("the limit_enable is: %d\n", limit_enable);
@@ -3217,143 +3401,118 @@ static ssize_t limit_enable_read(struct file *file, char __user *user_buf, size_
 
 static ssize_t limit_enable_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
 {
-        int ret;
-	char buf[8]={0};
-        int limit_mode = 0;
+	int ret;
+	char buf[8] = {0};
+	int limit_mode = 0;
 
-	if(version_is_s3508)
+	if (version_is_s3508)
 		F51_CUSTOM_CTRL74 = 0x0437;
 	else
 		F51_CUSTOM_CTRL74 = 0x044D;
 
-	if( count > 2)
+	if (count > 2)
 		count = 2;
-	if(ts_g == NULL)
-	{
+
+	if (ts_g == NULL) {
 		TPD_ERR("ts_g is NULL!\n");
 		return -1;
 	}
-	if(copy_from_user(buf, buffer, count))
-	{
+
+	if (copy_from_user(buf, buffer, count)) {
 		TPD_DEBUG("%s: read proc input error.\n", __func__);
 		return count;
 	}
 
-	if('0' == buf[0]){
+	if ('0' == buf[0]) {
 		limit_enable = 0;
-	}else if('1' == buf[0]){
+	} else if ('1' == buf[0]) {
 		limit_enable = 1;
 	}
+
 	msleep(30);
 	mutex_lock(&ts_g->mutex);
-        ret = i2c_smbus_write_byte_data(ts_g->client, 0xff, 0x4);
-        limit_mode = i2c_smbus_read_byte_data(ts_g->client, F51_CUSTOM_CTRL74);
-        TPD_ERR("%s_proc limit_enable =%d,mode:0x%x !\n", __func__,limit_enable,limit_mode);
-	if(limit_mode){
+	ret = i2c_smbus_write_byte_data(ts_g->client, 0xff, 0x4);
+	limit_mode = i2c_smbus_read_byte_data(ts_g->client, F51_CUSTOM_CTRL74);
+	TPD_ERR("%s_proc limit_enable =%d,mode:0x%x !\n", __func__, limit_enable, limit_mode);
+
+	if (limit_mode) {
 		i2c_smbus_write_byte_data(ts_g->client, 0xff, 0x4);
-		if(0 == limit_enable)
-		{
+
+		if (0 == limit_enable) {
 			limit_mode = limit_mode & 0xFE;
 			ret = i2c_smbus_write_byte_data(ts_g->client, F51_CUSTOM_CTRL74, limit_mode);
-		}
-		else if(1 == limit_enable)
-		{
+		} else if (1 == limit_enable) {
 			limit_mode = limit_mode | 0x1;
 			ret = i2c_smbus_write_byte_data(ts_g->client, F51_CUSTOM_CTRL74, limit_mode);
 		}
 	}
+
 	i2c_smbus_write_byte_data(ts_g->client, 0xff, 0x0);
 	mutex_unlock(&ts_g->mutex);
 	return count;
 }
 
-static const struct file_operations proc_limit_enable =
-{
+static const struct file_operations tpedge_limit_enable_proc_fops = {
 	.read = limit_enable_read,
 	.write = limit_enable_write,
 	.open = simple_open,
 	.owner = THIS_MODULE,
 };
 #endif
+
 #ifdef SUPPORT_TP_TOUCHKEY
-static ssize_t key_switch_read_func(struct file *file, char __user *user_buf, size_t count, loff_t *ppos)
+static ssize_t key_swap_read_func(struct file *file, char __user *user_buf, size_t count, loff_t *ppos)
 {
 	int ret = 0;
 	char page[PAGESIZE];
-	struct synaptics_ts_data *ts = ts_g;
-	if(!ts)
-		return ret;
-	TPD_ERR("%s lift:%s right:%s\n",__func__,key_switch?"key_appselect":"key_back",key_switch?"key_back":"key_appselect");
-	ret = sprintf(page, "key_switch lift:%s right:%s\n", key_switch?"key_appselect":"key_back",key_switch?"key_back":"key_appselect");
+
+	ret = sprintf(page, "%d\n", ts_g->key_swap);
 	ret = simple_read_from_buffer(user_buf, count, ppos, page, strlen(page));
+
 	return ret;
 }
 
-static ssize_t key_switch_write_func(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
+static ssize_t key_swap_write_func(struct file *file, const char __user *user_buf, size_t count, loff_t *ppos)
 {
-	char buf[4] = {0};
-	struct synaptics_ts_data *ts = ts_g;
-	if(!ts)
-		return count;
-	if(count > 2)
-		return count;
-	if(copy_from_user(buf, buffer, count))
-	{
-		TPD_ERR("%s copy error\n", __func__);
-		return count;
-	}
-	sscanf(&buf[0], "%d", &key_switch);
-	TPD_ERR("%s write [%d]\n",__func__,key_switch);
-	TPD_ERR("lift:%s right:%s\n",key_switch?"key_appselect":"key_back",key_switch?"key_back":"key_appselect");
+	int ret, write_flag = 0;
+	char page[PAGESIZE] = {0};
+
+	ret = copy_from_user(page, user_buf, count);
+	ret = sscanf(page, "%d", &write_flag);
+
+	ts_g->key_swap = (write_flag != 0);
+
 	return count;
 }
 
-static const struct file_operations key_switch_proc_fops = {
-	.write = key_switch_write_func,
-	.read =  key_switch_read_func,
+static const struct file_operations key_rep_proc_fops = {
+	.write = key_swap_write_func,
+	.read =  key_swap_read_func,
 	.open = simple_open,
 	.owner = THIS_MODULE,
 };
+
 static ssize_t key_disable_read_func(struct file *file, char __user *user_buf, size_t count, loff_t *ppos)
 {
 	int ret = 0;
 	char page[PAGESIZE];
-	struct synaptics_ts_data *ts = ts_g;
-	if(!ts)
-		return ret;
-	TPD_ERR("%s key_back:%s key_appselect:%s\n",__func__,key_back_disable?"disable":"enable",key_appselect_disable?"disable":"enable");
-	ret = sprintf(page, "cmd:enable,disable\nkey_back:%s key_appselect:%s\n",key_back_disable?"disable":"enable",key_appselect_disable?"disable":"enable");
+
+	ret = sprintf(page, "%d\n", ts_g->key_disable);
 	ret = simple_read_from_buffer(user_buf, count, ppos, page, strlen(page));
+
 	return ret;
 }
 
-static ssize_t key_disable_write_func(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)
+static ssize_t key_disable_write_func(struct file *file, const char __user *user_buf, size_t count, loff_t *ppos)
 {
-	char buf[PAGESIZE];
-	struct synaptics_ts_data *ts = ts_g;
-	if(!ts)
-		return count;
-	if( count > sizeof(buf)){
-		TPD_ERR("%s error\n",__func__);
-		return count;
-	}
+	int ret, write_flag = 0;
+	char page[PAGESIZE] = {0};
+
+	ret = copy_from_user(page, user_buf, count);
+	ret = sscanf(page, "%d", &write_flag);
+
+	ts_g->key_disable = (write_flag != 0);
 
-	if(copy_from_user(buf, buffer, count))
-	{
-		TPD_ERR("%s copy error\n", __func__);
-		return count;
-	}
-	if (NULL != strstr(buf,"disable"))
-	{
-		key_back_disable =true;
-		key_appselect_disable = true;
-	}
-	else if (NULL != strstr(buf,"enable"))
-	{
-		key_back_disable =false;
-		key_appselect_disable = false;
-	}
-	TPD_ERR("%s key_back:%d key_appselect:%d\n",__func__,key_back_disable,key_appselect_disable);
 	return count;
 }
 
@@ -3364,113 +3523,90 @@ static const struct file_operations key_disable_proc_fops = {
 	.owner = THIS_MODULE,
 };
 #endif
+
+#define CREATE_PROC_NODE(PARENT, NAME, MODE)\
+	node = proc_create(#NAME, MODE, PARENT, &NAME##_proc_fops);\
+	if (node == NULL) {\
+		ret = -ENOMEM;\
+		TPD_ERR("Couldn't create " #NAME " in " #PARENT "\n");\
+	}
+
+#define CREATE_GESTURE_NODE(NAME)\
+	CREATE_PROC_NODE(touchpanel, NAME##_enable, 0666)
+
 static int init_synaptics_proc(void)
 {
 	int ret = 0;
-	struct proc_dir_entry *prEntry_tmp  = NULL;
-	prEntry_tp = proc_mkdir("touchpanel", NULL);
-	if( prEntry_tp == NULL ){
+
+	struct proc_dir_entry *touchpanel = NULL;
+#ifdef SUPPORT_TP_TOUCHKEY
+	struct proc_dir_entry *s1302 = NULL;
+#endif
+
+	struct proc_dir_entry *node  = NULL;
+
+	touchpanel = proc_mkdir("touchpanel", NULL);
+	if (touchpanel == NULL) {
 		ret = -ENOMEM;
 		TPD_ERR("Couldn't create touchpanel\n");
 	}
 
-#ifdef SUPPORT_GESTURE
-	prEntry_tmp = proc_create( "gesture_enable", 0666, prEntry_tp, &tp_gesture_proc_fops);
-	if(prEntry_tmp == NULL){
-		ret = -ENOMEM;
-        TPD_ERR("Couldn't create gesture_enable\n");
-	}
-	prEntry_tmp = proc_create( "gesture_switch", 0666, prEntry_tp, &gesture_switch_proc_fops);
-	if(prEntry_tmp == NULL){
-		ret = -ENOMEM;
-		TPD_ERR("Couldn't create gesture_switch\n");
-	}
-	prEntry_tmp = proc_create("coordinate", 0444, prEntry_tp, &coordinate_proc_fops);
-	if(prEntry_tmp == NULL){
+#ifdef SUPPORT_TP_TOUCHKEY
+	s1302 = proc_mkdir("s1302", NULL);
+	if (s1302 == NULL) {
 		ret = -ENOMEM;
-        TPD_ERR("Couldn't create coordinate\n");
+		TPD_ERR("Couldn't create s1302\n");
 	}
 #endif
 
+#ifdef SUPPORT_GESTURE
+	CREATE_PROC_NODE(touchpanel, coordinate, 0444);
+	CREATE_GESTURE_NODE(double_tap);
+	CREATE_GESTURE_NODE(up_arrow);
+	CREATE_GESTURE_NODE(down_arrow);
+	CREATE_GESTURE_NODE(left_arrow);
+	CREATE_GESTURE_NODE(right_arrow);
+	CREATE_GESTURE_NODE(double_swipe);
+	CREATE_GESTURE_NODE(up_swipe);
+	CREATE_GESTURE_NODE(down_swipe);
+	CREATE_GESTURE_NODE(left_swipe);
+	CREATE_GESTURE_NODE(right_swipe);
+	CREATE_GESTURE_NODE(letter_o);
+	CREATE_GESTURE_NODE(letter_w);
+	CREATE_GESTURE_NODE(letter_m);
+	CREATE_GESTURE_NODE(letter_s);
+#endif
+
 #ifdef SUPPORT_GLOVES_MODE
-	prEntry_tmp = proc_create( "glove_mode_enable", 0666, prEntry_tp,&glove_mode_enable_proc_fops);
-	if(prEntry_tmp == NULL) {
-		ret = -ENOMEM;
-        TPD_ERR("Couldn't create glove_mode_enable\n");
-	}
+	CREATE_PROC_NODE(touchpanel, glove_mode_enable, 0666);
 #endif
 
 #ifdef SUPPORT_TP_SLEEP_MODE
-	prEntry_tmp = proc_create("sleep_mode_enable", 0666, prEntry_tp, &sleep_mode_enable_proc_fops);
-	if( prEntry_tmp == NULL ){
-		ret = -ENOMEM;
-        TPD_ERR("Couldn't create sleep_mode_enable\n");
-	}
+	CREATE_PROC_NODE(touchpanel, sleep_mode_enable, 0666);
 #endif
 
-#ifdef RESET_ONESECOND
-	prEntry_tmp = proc_create( "tp_reset", 0666, prEntry_tp, &tp_reset_proc_fops);
-	if( prEntry_tmp == NULL ){
-		ret = -ENOMEM;
-        TPD_ERR("Couldn't create tp_reset\n");
-	}
-#endif
-#ifdef ENABLE_TPEDGE_LIMIT
-	prEntry_tmp = proc_create("tpedge_limit_enable", 0666, prEntry_tp, &proc_limit_enable);
-	if( prEntry_tmp == NULL ){
-		ret = -ENOMEM;
-        TPD_ERR("Couldn't create tp_limit_enable\n");
-	}
+#ifdef RESET_ONESECOND
+	CREATE_PROC_NODE(touchpanel, tp_reset, 0666);
 #endif
 
-	//wangwenxue@BSP add for change baseline_test to "proc\touchpanel\baseline_test"  begin
-	prEntry_tmp = proc_create( "baseline_test", 0666, prEntry_tp, &tp_baseline_test_proc_fops);
-	if(prEntry_tmp == NULL){
-		ret = -ENOMEM;
-        TPD_ERR("Couldn't create baseline_test\n");
-	}
-	//wangwenxue@BSP add for change baseline_test to "proc\touchpanel\baseline_test"  end
-	//wangwenxue@BSP add for change baseline_test to "proc\touchpanel\i2c_device_test"  begin
-	prEntry_tmp = proc_create( "i2c_device_test", 0666, prEntry_tp, &i2c_device_test_fops);
-	if(prEntry_tmp == NULL){
-		ret = -ENOMEM;
-        TPD_ERR("Couldn't create i2c_device_test\n");
-	}
+#ifdef ENABLE_TPEDGE_LIMIT
+	CREATE_PROC_NODE(touchpanel, tpedge_limit_enable, 0666);
+#endif
 
-	prEntry_tmp = proc_create( "radd", 0777, prEntry_tp, &base_register_address);
-	if(prEntry_tmp == NULL){
-		ret = -ENOMEM;
-        TPD_ERR("Couldn't create radd\n");
-	}
-	prEntry_tmp = proc_create("vendor_id", 0444, prEntry_tp, &vendor_id_proc_fops);
-	if(prEntry_tmp == NULL){
-		ret = -ENOMEM;
-        TPD_ERR("Couldn't create vendor_id\n");
-	}
-	prEntry_tmp = proc_create("changer_connet", 0666, prEntry_tp, &changer_ops);
-	if(prEntry_tmp == NULL){
-		ret = -ENOMEM;
-        TPD_ERR("Couldn't create changer_connet\n");
-	}
+	//wangwenxue@BSP add for change baseline_test to "proc\touchpanel\baseline_test"
+	CREATE_PROC_NODE(touchpanel, baseline_test, 0666);
+	//wangwenxue@BSP add for change baseline_test to "proc\touchpanel\i2c_device_test"
+	CREATE_PROC_NODE(touchpanel, i2c_device_test, 0666);
+	CREATE_PROC_NODE(touchpanel, radd, 0777);
+	CREATE_PROC_NODE(touchpanel, vendor_id, 0444);
+	CREATE_PROC_NODE(touchpanel, changer_connet, 0666);
+	CREATE_PROC_NODE(touchpanel, touch_press, 0666);
 
-	prEntry_tmp = proc_create("touch_press", 0666, prEntry_tp, &touch_press_status);
-	if(prEntry_tmp == NULL){
-		ret = -ENOMEM;
-        TPD_ERR("Couldn't create touch_press\n");
-	}
 #ifdef SUPPORT_TP_TOUCHKEY
-	prEntry_tmp = proc_create("key_switch", 0666, prEntry_tp, &key_switch_proc_fops);
-	if(prEntry_tmp == NULL){
-		ret = -ENOMEM;
-        TPD_ERR("Couldn't create key_switch\n");
-	}
-
-	prEntry_tmp = proc_create("key_disable", 0666, prEntry_tp, &key_disable_proc_fops);
-	if(prEntry_tmp == NULL){
-		ret = -ENOMEM;
-        TPD_ERR("Couldn't create key_disable\n");
-	}
+	CREATE_PROC_NODE(s1302, key_rep, 0666);
+	CREATE_PROC_NODE(touchpanel, key_disable, 0666);
 #endif
+
 	return ret;
 }
 /******************************end****************************/
@@ -3495,7 +3631,7 @@ static void re_scan_PDT(struct i2c_client *client)
 	SynaF34ReflashQuery_BootID = SynaF34QueryBase;
 	SynaF34ReflashQuery_FlashPropertyQuery = SynaF34QueryBase + 1;
 	SynaF34ReflashQuery_FirmwareBlockSize = SynaF34QueryBase + 2;
-	SynaF34ReflashQuery_FirmwareBlockCount = SynaF34QueryBase +3;
+	SynaF34ReflashQuery_FirmwareBlockCount = SynaF34QueryBase + 3;
 	SynaF34ReflashQuery_ConfigBlockSize = SynaF34QueryBase + 3;
 	SynaF34ReflashQuery_ConfigBlockCount = SynaF34QueryBase + 3;
 	i2c_smbus_read_i2c_block_data(client, SynaF34ReflashQuery_FirmwareBlockSize, 2, buf);
@@ -3503,14 +3639,15 @@ static void re_scan_PDT(struct i2c_client *client)
 	TPD_DEBUG("SynaFirmwareBlockSize 3310 is %d\n", SynaFirmwareBlockSize);
 	SynaF34_FlashControl = SynaF34DataBase + 2;
 }
+
 struct image_header {
 	/* 0x00 - 0x0f */
 	unsigned char checksum[4];
 	unsigned char reserved_04;
 	unsigned char reserved_05;
-	unsigned char options_firmware_id:1;
-	unsigned char options_contain_bootloader:1;
-	unsigned char options_reserved:6;
+	unsigned char options_firmware_id: 1;
+	unsigned char options_contain_bootloader: 1;
+	unsigned char options_reserved: 6;
 	unsigned char bootloader_version;
 	unsigned char firmware_size[4];
 	unsigned char config_size[4];
@@ -3544,13 +3681,13 @@ struct image_header_data {
 static unsigned int extract_uint_le(const unsigned char *ptr)
 {
 	return (unsigned int)ptr[0] +
-		(unsigned int)ptr[1] * 0x100 +
-		(unsigned int)ptr[2] * 0x10000 +
-		(unsigned int)ptr[3] * 0x1000000;
+	       (unsigned int)ptr[1] * 0x100 +
+	       (unsigned int)ptr[2] * 0x10000 +
+	       (unsigned int)ptr[3] * 0x1000000;
 }
 
 static void parse_header(struct image_header_data *header,
-		const unsigned char *fw_image)
+                         const unsigned char *fw_image)
 {
 	struct image_header *data = (struct image_header *)fw_image;
 
@@ -3569,11 +3706,12 @@ static void parse_header(struct image_header_data *header,
 	header->product_id[sizeof(data->product_id)] = 0;
 
 	memcpy(header->product_info, data->product_info,
-			sizeof(data->product_info));
+	       sizeof(data->product_info));
 
 	header->contains_firmware_id = data->options_firmware_id;
 	TPD_DEBUG(" debug header->contains_firmware_id is %x\n", header->contains_firmware_id);
-	if( header->contains_firmware_id )
+
+	if (header->contains_firmware_id)
 		header->firmware_id = extract_uint_le(data->firmware_id);
 
 	return;
@@ -3581,71 +3719,82 @@ static void parse_header(struct image_header_data *header,
 
 static int checkFlashState(struct i2c_client *client)
 {
-	int ret ;
+	int ret;
 	int count = 0;
-	ret =  synaptics_rmi4_i2c_read_byte(client,SynaF34_FlashControl+1);
-	while ( (ret != 0x80)&&(count < 8) ) {
+	ret =  synaptics_rmi4_i2c_read_byte(client, SynaF34_FlashControl + 1);
+
+	while ((ret != 0x80) && (count < 8)) {
 		msleep(3); //wait 3ms
-		ret =  synaptics_rmi4_i2c_read_byte(client,SynaF34_FlashControl+1);
+		ret =  synaptics_rmi4_i2c_read_byte(client, SynaF34_FlashControl + 1);
 		count++;
 	}
-	if(count == 8)
+
+	if (count == 8)
 		return 1;
 	else
 		return 0;
 }
 
-static int synaptics_fw_check(struct synaptics_ts_data *ts )
+static int synaptics_fw_check(struct synaptics_ts_data *ts)
 {
 	int ret;
 	uint8_t buf[4];
 	uint32_t bootloader_mode;
 	int max_y_ic = 0;
 	int max_x_ic = 0;
-	if(!ts){
-		TPD_ERR("%s ts is NULL\n",__func__);
+
+	if (!ts) {
+		TPD_ERR("%s ts is NULL\n", __func__);
 		return -1;
 	}
 
 	ret = synaptics_enable_interrupt(ts, 0);
-	if(ret < 0) {
+
+	if (ret < 0) {
 		TPDTM_DMESG(" synaptics_ts_probe: disable interrupt failed\n");
 	}
 
 	/*read product id */
 	ret = synaptics_read_product_id(ts);
-	if(ret) {
+
+	if (ret) {
 		TPD_ERR("failed to read product info \n");
 		return -1;
 	}
+
 	/*read max_x ,max_y*/
 	ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x0);
+
 	if (ret < 0) {
 		ret = synaptics_rmi4_i2c_write_byte(ts->client, 0xff, 0x0);
-		if(ret < 0 ){
+
+		if (ret < 0) {
 			TPD_ERR("synaptics_rmi4_i2c_write_byte failed for page select\n");
 			return -1;
 		}
 	}
 
 	i2c_smbus_read_i2c_block_data(ts->client, F12_2D_CTRL08, 4, buf);
-	max_x_ic = ( (buf[1]<<8)&0xffff ) | (buf[0]&0xffff);
-	max_y_ic = ( (buf[3]<<8)&0xffff ) | (buf[2]&0xffff);
+	max_x_ic = ((buf[1] << 8) & 0xffff) | (buf[0] & 0xffff);
+	max_y_ic = ((buf[3] << 8) & 0xffff) | (buf[2] & 0xffff);
 
-	TPD_ERR("max_x = %d,max_y = %d; max_x_ic = %d,max_y_ic = %d\n",ts->max_x,ts->max_y,max_x_ic,max_y_ic);
-	if((ts->max_x == 0) ||(ts->max_y ==0 )) {
+	TPD_ERR("max_x = %d,max_y = %d; max_x_ic = %d,max_y_ic = %d\n", ts->max_x, ts->max_y, max_x_ic, max_y_ic);
+
+	if ((ts->max_x == 0) || (ts->max_y == 0)) {
 		ts->max_x = max_x_ic;
 		ts->max_y = max_y_ic;
 	}
-	bootloader_mode = synaptics_rmi4_i2c_read_byte(ts->client,F01_RMI_DATA_BASE);
-	bootloader_mode = bootloader_mode&0xff;
-	bootloader_mode = bootloader_mode&0x40;
-	TPD_DEBUG("afte fw update,program memory self-check bootloader_mode = 0x%x\n",bootloader_mode);
 
-	if((max_x_ic == 0)||(max_y_ic == 0)||(bootloader_mode == 0x40)) {
+	bootloader_mode = synaptics_rmi4_i2c_read_byte(ts->client, F01_RMI_DATA_BASE);
+	bootloader_mode = bootloader_mode & 0xff;
+	bootloader_mode = bootloader_mode & 0x40;
+	TPD_DEBUG("afte fw update,program memory self-check bootloader_mode = 0x%x\n", bootloader_mode);
+
+	if ((max_x_ic == 0) || (max_y_ic == 0) || (bootloader_mode == 0x40)) {
 		TPD_ERR("Something terrible wrong \n Trying Update the Firmware again\n");
 		return -1;
 	}
+
 	return 0;
 }
 
@@ -3665,7 +3814,7 @@ static void re_scan_PDT_s3508(struct i2c_client *client)
 	SynaF34ReflashQuery_BootID = SynaF34QueryBase;
 	SynaF34ReflashQuery_FlashPropertyQuery = SynaF34QueryBase + 1;
 	SynaF34ReflashQuery_FirmwareBlockSize = SynaF34QueryBase + 2;
-	SynaF34ReflashQuery_FirmwareBlockCount = SynaF34QueryBase +3;
+	SynaF34ReflashQuery_FirmwareBlockCount = SynaF34QueryBase + 3;
 	SynaF34ReflashQuery_ConfigBlockSize = SynaF34QueryBase + 3;
 	SynaF34ReflashQuery_ConfigBlockCount = SynaF34QueryBase + 3;
 	i2c_smbus_read_i2c_block_data(client, SynaF34ReflashQuery_FirmwareBlockSize, 2, buf);
@@ -3674,142 +3823,162 @@ static void re_scan_PDT_s3508(struct i2c_client *client)
 	SynaF34_FlashControl = SynaF34DataBase + 2;
 }
 
-static int synapitcs_ts_update(struct i2c_client *client, const uint8_t *data, uint32_t data_len ,bool force)
+static int synapitcs_ts_update(struct i2c_client *client, const uint8_t *data, uint32_t data_len, bool force)
 {
-	int ret,j;
+	int ret, j;
 	uint8_t buf[8];
 	uint8_t bootloder_id[10];
-	uint16_t block,firmware,configuration;
-	uint32_t CURRENT_FIRMWARE_ID = 0 , FIRMWARE_ID = 0;
+	uint16_t block, firmware, configuration;
+	uint32_t CURRENT_FIRMWARE_ID = 0, FIRMWARE_ID = 0;
 	const uint8_t *Config_Data = NULL;
 	const uint8_t *Firmware_Data = NULL;
 	struct image_header_data header;
 	struct synaptics_ts_data *ts = dev_get_drvdata(&client->dev);
-	TPD_DEBUG("%s is called\n",__func__);
-	if(!client)
+	TPD_DEBUG("%s is called\n", __func__);
+
+	if (!client)
 		return -1;
-	if (!strncmp(ts->manu_name,"S3718",5)){
+
+	if (!strncmp(ts->manu_name, "S3718", 5)) {
 		Config_Data = data + 0x8f0;
 		ret = synaptics_rmi4_i2c_write_byte(client, 0xff, 0x0);
 		ret = synaptics_rmi4_i2c_read_block(client, F34_FLASH_CTRL00, 4, buf);
-		CURRENT_FIRMWARE_ID = (buf[0]<<24)|(buf[1]<<16)|(buf[2]<<8)|buf[3];
-		FIRMWARE_ID = (Config_Data[0]<<24)|(Config_Data[1]<<16)|(Config_Data[2]<<8)|Config_Data[3];
-		if(1 == check_version)
-			TPD_ERR("15801CURRENT_FW_ID:%x----, FW_ID:%x----,FW_NAME:%s\n", CURRENT_FIRMWARE_ID, FIRMWARE_ID,ts->fw_name);
+		CURRENT_FIRMWARE_ID = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
+		FIRMWARE_ID = (Config_Data[0] << 24) | (Config_Data[1] << 16) | (Config_Data[2] << 8) | Config_Data[3];
+
+		if (1 == check_version)
+			TPD_ERR("15801CURRENT_FW_ID:%x----, FW_ID:%x----,FW_NAME:%s\n", CURRENT_FIRMWARE_ID, FIRMWARE_ID, ts->fw_name);
 		else
-			TPD_ERR("15801CURRENT_FW_ID:%xvB----, FW_ID:%xvB----,FW_NAME:%s\n", CURRENT_FIRMWARE_ID, FIRMWARE_ID,ts->fw_name);
+			TPD_ERR("15801CURRENT_FW_ID:%xvB----, FW_ID:%xvB----,FW_NAME:%s\n", CURRENT_FIRMWARE_ID, FIRMWARE_ID, ts->fw_name);
+
 		//TPD_ERR("synaptics force is %d\n", force);
-		if(!force) {
-			if(CURRENT_FIRMWARE_ID == FIRMWARE_ID) {
+		if (!force) {
+			if (CURRENT_FIRMWARE_ID == FIRMWARE_ID) {
 				return 0;
 			}
 		}
-		ret = fwu_start_reflash(data,client);
-		if (ret){
+
+		ret = fwu_start_reflash(data, client);
+
+		if (ret) {
 			return -1;
 		}
-	}else if(!strncmp(ts->manu_name,"s3508",5) || !strncmp(ts->manu_name,"15811",5)){
-		parse_header(&header,data);
-		if((header.firmware_size + header.config_size + 0x100) > data_len) {
-			TPDTM_DMESG("firmware_size + config_size + 0x100 > data_len data_len = %d \n",data_len);
+	} else if (!strncmp(ts->manu_name, "s3508", 5) || !strncmp(ts->manu_name, "15811", 5)) {
+		parse_header(&header, data);
+
+		if ((header.firmware_size + header.config_size + 0x100) > data_len) {
+			TPDTM_DMESG("firmware_size + config_size + 0x100 > data_len data_len = %d \n", data_len);
 			return -1;
 		}
+
 		Firmware_Data = data + 0x100;
 		Config_Data = Firmware_Data + header.firmware_size;
 		ret = i2c_smbus_write_byte_data(client, 0xff, 0x0);
 
 		ret = i2c_smbus_read_i2c_block_data(client, F34_FLASH_CTRL00, 4, buf);
-		CURRENT_FIRMWARE_ID = (buf[0]<<24)|(buf[1]<<16)|(buf[2]<<8)|buf[3];
-		FIRMWARE_ID = (Config_Data[0]<<24)|(Config_Data[1]<<16)|(Config_Data[2]<<8)|Config_Data[3];
-		TPD_ERR("15811CURRENT_FW_ID:%x----, FW_ID:%x----,FW_NAME:%s\n", CURRENT_FIRMWARE_ID, FIRMWARE_ID,ts->fw_name);
+		CURRENT_FIRMWARE_ID = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
+		FIRMWARE_ID = (Config_Data[0] << 24) | (Config_Data[1] << 16) | (Config_Data[2] << 8) | Config_Data[3];
+		TPD_ERR("15811CURRENT_FW_ID:%x----, FW_ID:%x----,FW_NAME:%s\n", CURRENT_FIRMWARE_ID, FIRMWARE_ID, ts->fw_name);
 		TPD_ERR("synaptics force is %d\n", force);
-		if(!force) {
-			if(CURRENT_FIRMWARE_ID == FIRMWARE_ID) {
+
+		if (!force) {
+			if (CURRENT_FIRMWARE_ID == FIRMWARE_ID) {
 				return 0;
 			}
 		}
+
 		re_scan_PDT_s3508(client);
 		block = 16;
-		TPD_DEBUG("block is %d \n",block);
-		firmware = (header.firmware_size)/16;
-		TPD_DEBUG("firmware is %d \n",firmware);
-		configuration = (header.config_size)/16;
-		TPD_DEBUG("configuration is %d \n",configuration);
+		TPD_DEBUG("block is %d \n", block);
+		firmware = (header.firmware_size) / 16;
+		TPD_DEBUG("firmware is %d \n", firmware);
+		configuration = (header.config_size) / 16;
+		TPD_DEBUG("configuration is %d \n", configuration);
 
 		ret = i2c_smbus_read_i2c_block_data(client, SynaF34ReflashQuery_BootID, 8, &(bootloder_id[0]));
-		TPD_DEBUG("bootloader id is %x \n",(bootloder_id[1] << 8)|bootloder_id[0]);
-		ret=i2c_smbus_write_i2c_block_data(client, SynaF34Reflash_BlockData, 2, &(bootloder_id[0x0]));
-		TPD_DEBUG("Write bootloader id SynaF34_FlashControl is 0x00%x ret is %d\n",SynaF34_FlashControl,ret);
+		TPD_DEBUG("bootloader id is %x \n", (bootloder_id[1] << 8) | bootloder_id[0]);
+		ret = i2c_smbus_write_i2c_block_data(client, SynaF34Reflash_BlockData, 2, &(bootloder_id[0x0]));
+		TPD_DEBUG("Write bootloader id SynaF34_FlashControl is 0x00%x ret is %d\n", SynaF34_FlashControl, ret);
 
-		i2c_smbus_write_byte_data(client,SynaF34_FlashControl,0x0F);
+		i2c_smbus_write_byte_data(client, SynaF34_FlashControl, 0x0F);
 		msleep(10);
 		TPD_DEBUG("attn step 4\n");
-		ret=checkFlashState(client);
-		if(ret > 0) {
-			TPD_ERR("Get in prog:The status(Image) of flashstate is %x\n",ret);
-				return -1;
+		ret = checkFlashState(client);
+
+		if (ret > 0) {
+			TPD_ERR("Get in prog:The status(Image) of flashstate is %x\n", ret);
+			return -1;
 		}
-		ret = i2c_smbus_read_byte_data(client,0x04);
-		TPD_DEBUG("The status(device state) is %x\n",ret);
-		ret= i2c_smbus_read_byte_data(client,F01_RMI_CTRL_BASE);
-		TPD_DEBUG("The status(control f01_RMI_CTRL_DATA) is %x\n",ret);
-		ret= i2c_smbus_write_byte_data(client,F01_RMI_CTRL_BASE,ret&0x04);
+
+		ret = i2c_smbus_read_byte_data(client, 0x04);
+		TPD_DEBUG("The status(device state) is %x\n", ret);
+		ret = i2c_smbus_read_byte_data(client, F01_RMI_CTRL_BASE);
+		TPD_DEBUG("The status(control f01_RMI_CTRL_DATA) is %x\n", ret);
+		ret = i2c_smbus_write_byte_data(client, F01_RMI_CTRL_BASE, ret & 0x04);
 		/********************get into prog end************/
-		ret=i2c_smbus_write_i2c_block_data(client, SynaF34Reflash_BlockData, 2, &(bootloder_id[0x0]));
-		TPD_DEBUG("ret is %d\n",ret);
+		ret = i2c_smbus_write_i2c_block_data(client, SynaF34Reflash_BlockData, 2, &(bootloder_id[0x0]));
+		TPD_DEBUG("ret is %d\n", ret);
 		re_scan_PDT_s3508(client);
-		i2c_smbus_read_i2c_block_data(client,SynaF34ReflashQuery_BootID,2,buf);
-		i2c_smbus_write_i2c_block_data(client,SynaF34Reflash_BlockData,2,buf);
-		i2c_smbus_write_byte_data(client,SynaF34_FlashControl,0x03);
+		i2c_smbus_read_i2c_block_data(client, SynaF34ReflashQuery_BootID, 2, buf);
+		i2c_smbus_write_i2c_block_data(client, SynaF34Reflash_BlockData, 2, buf);
+		i2c_smbus_write_byte_data(client, SynaF34_FlashControl, 0x03);
 		msleep(2500);
 		ret = i2c_smbus_read_byte_data(client, SynaF34_FlashControl);
-		if(ret != 0x00)
+
+		if (ret != 0x00)
 			msleep(2000);
-		ret = i2c_smbus_read_byte_data(client,SynaF34_FlashControl+1);
-		TPDTM_DMESG("The status(erase) is %x\n",ret);
+
+		ret = i2c_smbus_read_byte_data(client, SynaF34_FlashControl + 1);
+		TPDTM_DMESG("The status(erase) is %x\n", ret);
 		TPD_ERR("15811update-----------------update------------------update!\n");
-		TPD_DEBUG("cnt %d\n",firmware);
-		for(j=0; j<firmware; j++) {
-			buf[0]=j&0x00ff;
-			buf[1]=(j&0xff00)>>8;
-			i2c_smbus_write_i2c_block_data(client,SynaF34Reflash_BlockNum,2,buf);
-			i2c_smbus_write_i2c_block_data(client,SynaF34Reflash_BlockData,16,&Firmware_Data[j*16]);
-
-			i2c_smbus_write_byte_data(client,SynaF34_FlashControl,0x02);
-			ret=checkFlashState(client);
-			if(ret > 0) {
-				TPD_ERR("Firmware:The status(Image) of flash data3 is %x,time =%d\n",ret,j);
+		TPD_DEBUG("cnt %d\n", firmware);
+
+		for (j = 0; j < firmware; j++) {
+			buf[0] = j & 0x00ff;
+			buf[1] = (j & 0xff00) >> 8;
+			i2c_smbus_write_i2c_block_data(client, SynaF34Reflash_BlockNum, 2, buf);
+			i2c_smbus_write_i2c_block_data(client, SynaF34Reflash_BlockData, 16, &Firmware_Data[j * 16]);
+
+			i2c_smbus_write_byte_data(client, SynaF34_FlashControl, 0x02);
+			ret = checkFlashState(client);
+
+			if (ret > 0) {
+				TPD_ERR("Firmware:The status(Image) of flash data3 is %x,time =%d\n", ret, j);
 				return -1;
 			}
 		}
+
 		//step 7 configure data
 		//TPD_ERR("going to flash configuration area\n");
 		//TPD_ERR("header.firmware_size is 0x%x\n", header.firmware_size);
 		//TPD_ERR("bootloader_size is 0x%x\n", bootloader_size);
-		for(j=0;j<configuration;j++) {
+		for (j = 0; j < configuration; j++) {
 			//a)write SynaF34Reflash_BlockNum to access
-			buf[0]=j&0x00ff;
-			buf[1]=(j&0xff00)>>8;
-			i2c_smbus_write_i2c_block_data(client,SynaF34Reflash_BlockNum,2,buf);
+			buf[0] = j & 0x00ff;
+			buf[1] = (j & 0xff00) >> 8;
+			i2c_smbus_write_i2c_block_data(client, SynaF34Reflash_BlockNum, 2, buf);
 			//b) write data
 
-				i2c_smbus_write_i2c_block_data(client,SynaF34Reflash_BlockData,16,&Config_Data[j*16]);
+			i2c_smbus_write_i2c_block_data(client, SynaF34Reflash_BlockData, 16, &Config_Data[j * 16]);
 
 			//c) issue write
-			i2c_smbus_write_byte_data(client,SynaF34_FlashControl,0x06);
+			i2c_smbus_write_byte_data(client, SynaF34_FlashControl, 0x06);
 			//d) wait attn
 			ret = checkFlashState(client);
-			if(ret > 0) {
-				TPD_ERR("Configuration:The status(Image) of flash data3 is %x,time =%d\n",ret,j);
+
+			if (ret > 0) {
+				TPD_ERR("Configuration:The status(Image) of flash data3 is %x,time =%d\n", ret, j);
 				return -1;
 			}
 		}
+
 		//step 1 issue reset
-		i2c_smbus_write_byte_data(client,SynaF01CommandBase,0X01);
-	}else{
-		parse_header(&header,data);
-		if((header.firmware_size + header.config_size + 0x100) > data_len) {
-			TPDTM_DMESG("firmware_size + config_size + 0x100 > data_len data_len = %d \n",data_len);
+		i2c_smbus_write_byte_data(client, SynaF01CommandBase, 0X01);
+	} else {
+		parse_header(&header, data);
+
+		if ((header.firmware_size + header.config_size + 0x100) > data_len) {
+			TPDTM_DMESG("firmware_size + config_size + 0x100 > data_len data_len = %d \n", data_len);
 			return -1;
 		}
 
@@ -3818,146 +3987,156 @@ static int synapitcs_ts_update(struct i2c_client *client, const uint8_t *data, u
 		ret = synaptics_rmi4_i2c_write_byte(client, 0xff, 0x0);
 
 		ret = synaptics_rmi4_i2c_read_block(client, F34_FLASH_CTRL00, 4, buf);
-		CURRENT_FIRMWARE_ID = (buf[0]<<24)|(buf[1]<<16)|(buf[2]<<8)|buf[3];
-		FIRMWARE_ID = (Config_Data[0]<<24)|(Config_Data[1]<<16)|(Config_Data[2]<<8)|Config_Data[3];
+		CURRENT_FIRMWARE_ID = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
+		FIRMWARE_ID = (Config_Data[0] << 24) | (Config_Data[1] << 16) | (Config_Data[2] << 8) | Config_Data[3];
 
 		//TPD_ERR("synaptics force is %d\n", force);
-		if(!force) {
-			if(CURRENT_FIRMWARE_ID == FIRMWARE_ID) {
+		if (!force) {
+			if (CURRENT_FIRMWARE_ID == FIRMWARE_ID) {
 				return 0;
 			}
 		}
+
 		re_scan_PDT(client);
 		block = 16;
-		TPD_DEBUG("block is %d \n",block);
-		firmware = (header.firmware_size)/16;
-		TPD_DEBUG("firmware is %d \n",firmware);
-		configuration = (header.config_size)/16;
-		TPD_DEBUG("configuration is %d \n",configuration);
+		TPD_DEBUG("block is %d \n", block);
+		firmware = (header.firmware_size) / 16;
+		TPD_DEBUG("firmware is %d \n", firmware);
+		configuration = (header.config_size) / 16;
+		TPD_DEBUG("configuration is %d \n", configuration);
 
 
 		ret = i2c_smbus_read_i2c_block_data(client, SynaF34ReflashQuery_BootID, 8, &(bootloder_id[0]));
-		TPD_DEBUG("bootloader id is %x \n",(bootloder_id[1] << 8)|bootloder_id[0]);
-		ret=i2c_smbus_write_i2c_block_data(client, SynaF34Reflash_BlockData, 2, &(bootloder_id[0x0]));
-		TPDTM_DMESG("Write bootloader id SynaF34_FlashControl is 0x00%x ret is %d\n",SynaF34_FlashControl,ret);
+		TPD_DEBUG("bootloader id is %x \n", (bootloder_id[1] << 8) | bootloder_id[0]);
+		ret = i2c_smbus_write_i2c_block_data(client, SynaF34Reflash_BlockData, 2, &(bootloder_id[0x0]));
+		TPDTM_DMESG("Write bootloader id SynaF34_FlashControl is 0x00%x ret is %d\n", SynaF34_FlashControl, ret);
 
-		synaptics_rmi4_i2c_write_byte(client,SynaF34_FlashControl,0x0F);
+		synaptics_rmi4_i2c_write_byte(client, SynaF34_FlashControl, 0x0F);
 		msleep(10);
 		TPD_DEBUG("attn step 4\n");
-		ret=checkFlashState(client);
-		if(ret > 0) {
-			TPD_ERR("Get in prog:The status(Image) of flashstate is %x\n",ret);
+		ret = checkFlashState(client);
+
+		if (ret > 0) {
+			TPD_ERR("Get in prog:The status(Image) of flashstate is %x\n", ret);
 			return -1;
 		}
-		ret = i2c_smbus_read_byte_data(client,0x04);
-		TPD_DEBUG("The status(device state) is %x\n",ret);
-		ret= i2c_smbus_read_byte_data(client,F01_RMI_CTRL_BASE);
-		TPD_DEBUG("The status(control f01_RMI_CTRL_DATA) is %x\n",ret);
-		ret= i2c_smbus_write_byte_data(client,F01_RMI_CTRL_BASE,ret&0x04);
+
+		ret = i2c_smbus_read_byte_data(client, 0x04);
+		TPD_DEBUG("The status(device state) is %x\n", ret);
+		ret = i2c_smbus_read_byte_data(client, F01_RMI_CTRL_BASE);
+		TPD_DEBUG("The status(control f01_RMI_CTRL_DATA) is %x\n", ret);
+		ret = i2c_smbus_write_byte_data(client, F01_RMI_CTRL_BASE, ret & 0x04);
 		/********************get into prog end************/
-		ret=i2c_smbus_write_i2c_block_data(client, SynaF34Reflash_BlockData, 2, &(bootloder_id[0x0]));
-		TPD_DEBUG("ret is %d\n",ret);
+		ret = i2c_smbus_write_i2c_block_data(client, SynaF34Reflash_BlockData, 2, &(bootloder_id[0x0]));
+		TPD_DEBUG("ret is %d\n", ret);
 		re_scan_PDT(client);
-		i2c_smbus_read_i2c_block_data(client,SynaF34ReflashQuery_BootID,2,buf);
-		i2c_smbus_write_i2c_block_data(client,SynaF34Reflash_BlockData,2,buf);
-		i2c_smbus_write_byte_data(client,SynaF34_FlashControl,0x03);
+		i2c_smbus_read_i2c_block_data(client, SynaF34ReflashQuery_BootID, 2, buf);
+		i2c_smbus_write_i2c_block_data(client, SynaF34Reflash_BlockData, 2, buf);
+		i2c_smbus_write_byte_data(client, SynaF34_FlashControl, 0x03);
 		msleep(2000);
-		ret = i2c_smbus_read_byte_data(client,SynaF34_FlashControl);
-		TPDTM_DMESG("going to flash firmware area synaF34_FlashControl %d\n",ret);
+		ret = i2c_smbus_read_byte_data(client, SynaF34_FlashControl);
+		TPDTM_DMESG("going to flash firmware area synaF34_FlashControl %d\n", ret);
 
 		TPD_ERR("update-----------------firmware ------------------update!\n");
-		TPD_DEBUG("cnt %d\n",firmware);
-		for(j=0; j<firmware; j++) {
-			buf[0]=j&0x00ff;
-			buf[1]=(j&0xff00)>>8;
-			synaptics_rmi4_i2c_write_block(client,SynaF34Reflash_BlockNum,2,buf);
-			synaptics_rmi4_i2c_write_block(client,SynaF34Reflash_BlockData,16,&Firmware_Data[j*16]);
-			synaptics_rmi4_i2c_write_byte(client,SynaF34_FlashControl,0x02);
-			ret=checkFlashState(client);
-			if(ret > 0) {
-				TPD_ERR("Firmware:The status(Image) of flash data3 is %x,time =%d\n",ret,j);
+		TPD_DEBUG("cnt %d\n", firmware);
+
+		for (j = 0; j < firmware; j++) {
+			buf[0] = j & 0x00ff;
+			buf[1] = (j & 0xff00) >> 8;
+			synaptics_rmi4_i2c_write_block(client, SynaF34Reflash_BlockNum, 2, buf);
+			synaptics_rmi4_i2c_write_block(client, SynaF34Reflash_BlockData, 16, &Firmware_Data[j * 16]);
+			synaptics_rmi4_i2c_write_byte(client, SynaF34_FlashControl, 0x02);
+			ret = checkFlashState(client);
+
+			if (ret > 0) {
+				TPD_ERR("Firmware:The status(Image) of flash data3 is %x,time =%d\n", ret, j);
 				return -1;
 			}
 		}
+
 		//step 7 configure data
 		//TPD_ERR("going to flash configuration area\n");
 		//TPD_ERR("header.firmware_size is 0x%x\n", header.firmware_size);
 		//TPD_ERR("bootloader_size is 0x%x\n", bootloader_size);
 		TPD_ERR("update-----------------configuration ------------------update!\n");
-		for(j=0;j<configuration;j++) {
+
+		for (j = 0; j < configuration; j++) {
 			//a)write SynaF34Reflash_BlockNum to access
-			buf[0]=j&0x00ff;
-			buf[1]=(j&0xff00)>>8;
-			synaptics_rmi4_i2c_write_block(client,SynaF34Reflash_BlockNum,2,buf);
+			buf[0] = j & 0x00ff;
+			buf[1] = (j & 0xff00) >> 8;
+			synaptics_rmi4_i2c_write_block(client, SynaF34Reflash_BlockNum, 2, buf);
 			//b) write data
-			synaptics_rmi4_i2c_write_block(client,SynaF34Reflash_BlockData,16,&Config_Data[j*16]);
+			synaptics_rmi4_i2c_write_block(client, SynaF34Reflash_BlockData, 16, &Config_Data[j * 16]);
 			//c) issue write
-			synaptics_rmi4_i2c_write_byte(client,SynaF34_FlashControl,0x06);
+			synaptics_rmi4_i2c_write_byte(client, SynaF34_FlashControl, 0x06);
 			//d) wait attn
 			ret = checkFlashState(client);
-			if(ret > 0) {
-				TPD_ERR("Configuration:The status(Image) of flash data3 is %x,time =%d\n",ret,j);
+
+			if (ret > 0) {
+				TPD_ERR("Configuration:The status(Image) of flash data3 is %x,time =%d\n", ret, j);
 				return -1;
 			}
 		}
 
 		//step 1 issue reset
-		synaptics_rmi4_i2c_write_byte(client,SynaF01CommandBase,0x01);
+		synaptics_rmi4_i2c_write_byte(client, SynaF01CommandBase, 0x01);
 	}
+
 	//step2 wait ATTN
 	//delay_qt_ms(1000);
 	mdelay(1500);
 	synaptics_read_register_map(ts);
 	//FW flash check!
-	ret =synaptics_fw_check(ts);
-	if(ret < 0 ) {
+	ret = synaptics_fw_check(ts);
+
+	if (ret < 0) {
 		TPD_ERR("Firmware self check failed\n");
 		return -1;
 	}
+
 	TPD_ERR("Firmware self check Ok\n");
 	return 0;
 }
+
 #ifdef ENABLE_TPEDGE_LIMIT
 static void synaptics_tpedge_limitfunc(void)
 {
-	int limit_mode=0;
+	int limit_mode = 0;
 	int ret;
 
-	if(version_is_s3508)
-	{
+	if (version_is_s3508) {
 		if (TP_FW > 0xeb101014)
 			F51_CUSTOM_CTRL74 = 0x0435;
 		else
 			F51_CUSTOM_CTRL74 = 0x0437;
-	}
-	else
-	{
+	} else {
 		F51_CUSTOM_CTRL74 = 0x044D;
 	}
-	TPD_DEBUG("%s line%d F51_CUSTOM_CTRL74 = 0x%x\n", __func__,__LINE__,F51_CUSTOM_CTRL74);
+
+	TPD_DEBUG("%s line%d F51_CUSTOM_CTRL74 = 0x%x\n", __func__, __LINE__, F51_CUSTOM_CTRL74);
 	msleep(60);
-        ret = i2c_smbus_write_byte_data(ts_g->client, 0xff, 0x4);
-        limit_mode = i2c_smbus_read_byte_data(ts_g->client, F51_CUSTOM_CTRL74);
-        TPD_ERR("%s limit_enable =%d,mode:0x%x !\n", __func__,limit_enable,limit_mode);
-	if(limit_mode){
+	ret = i2c_smbus_write_byte_data(ts_g->client, 0xff, 0x4);
+	limit_mode = i2c_smbus_read_byte_data(ts_g->client, F51_CUSTOM_CTRL74);
+	TPD_ERR("%s limit_enable =%d,mode:0x%x !\n", __func__, limit_enable, limit_mode);
+
+	if (limit_mode) {
 		i2c_smbus_write_byte_data(ts_g->client, 0xff, 0x4);
-		if(0 == limit_enable)
-		{
-			if(limit_mode & 0x1){
+
+		if (0 == limit_enable) {
+			if (limit_mode & 0x1) {
 				//TPD_ERR("000 limit_enable:0x%xs  !\n",limit_mode);
 				limit_mode = limit_mode & 0xFE;
 				ret = i2c_smbus_write_byte_data(ts_g->client, F51_CUSTOM_CTRL74, limit_mode);
 			}
-		}
-		else if(1 == limit_enable)
-		{
-			if(!(limit_mode & 0x1)){
+		} else if (1 == limit_enable) {
+			if (!(limit_mode & 0x1)) {
 				//TPD_ERR("111 limit_enable:x%xs  !\n",limit_mode);
 				limit_mode = limit_mode | 0x1;
 				ret = i2c_smbus_write_byte_data(ts_g->client, F51_CUSTOM_CTRL74, limit_mode);
 			}
 		}
 	}
+
 	i2c_smbus_write_byte_data(ts_g->client, 0xff, 0x0);
 }
 
@@ -3965,16 +4144,20 @@ static void synaptics_tpedge_limitfunc(void)
 static int synaptics_soft_reset(struct synaptics_ts_data *ts)
 {
 	int ret;
-	if(ts->loading_fw) {
-		TPD_ERR("%s FW is updating break!\n",__func__);
+
+	if (ts->loading_fw) {
+		TPD_ERR("%s FW is updating break!\n", __func__);
 		return -1;
 	}
+
 	touch_disable(ts);
 	ret = i2c_smbus_write_byte_data(ts->client, F01_RMI_CMD_BASE, 0x01);
-	if (ret < 0){
-		TPD_ERR("reset error ret=%d\n",ret);
+
+	if (ret < 0) {
+		TPD_ERR("reset error ret=%d\n", ret);
 	}
-	TPD_ERR("%s !!!\n",__func__);
+
+	TPD_ERR("%s !!!\n", __func__);
 	msleep(100);
 	touch_enable(ts);
 #ifdef ENABLE_TPEDGE_LIMIT
@@ -3982,18 +4165,18 @@ static int synaptics_soft_reset(struct synaptics_ts_data *ts)
 #endif
 	return ret;
 }
+
 static void synaptics_hard_reset(struct synaptics_ts_data *ts)
 {
-	if(ts->reset_gpio > 0)
-	{
-		gpio_set_value(ts->reset_gpio,0);
+	if (ts->reset_gpio > 0) {
+		gpio_set_value(ts->reset_gpio, 0);
 		msleep(5);
-		gpio_set_value(ts->reset_gpio,1);
+		gpio_set_value(ts->reset_gpio, 1);
 		msleep(100);
-		TPD_ERR("%s !!!\n",__func__);
+		TPD_ERR("%s !!!\n", __func__);
 	}
-
 }
+
 static int synaptics_parse_dts(struct device *dev, struct synaptics_ts_data *ts)
 {
 	int rc;
@@ -4004,162 +4187,196 @@ static int synaptics_parse_dts(struct device *dev, struct synaptics_ts_data *ts)
 
 	np = dev->of_node;
 	ts->irq_gpio = of_get_named_gpio_flags(np, "synaptics,irq-gpio", 0, &(ts->irq_flags));
-	if( ts->irq_gpio < 0 ){
+
+	if (ts->irq_gpio < 0) {
 		TPD_DEBUG("ts->irq_gpio not specified\n");
 	}
 
 	ts->reset_gpio = of_get_named_gpio(np, "synaptics,reset-gpio", 0);
-	if( ts->reset_gpio < 0 ){
+
+	if (ts->reset_gpio < 0) {
 		TPD_DEBUG("ts->reset-gpio  not specified\n");
 	}
+
 	ts->v1p8_gpio = of_get_named_gpio(np, "synaptics,1v8-gpio", 0);
-	if( ts->v1p8_gpio < 0 ){
+
+	if (ts->v1p8_gpio < 0) {
 		TPD_DEBUG("ts->1v8-gpio  not specified\n");
 	}
 
-	if(of_property_read_bool(np, "oem,support_hw_poweroff"))
-		ts->support_hw_poweroff=true;
+	if (of_property_read_bool(np, "oem,support_hw_poweroff"))
+		ts->support_hw_poweroff = true;
 	else
-		ts->support_hw_poweroff=false;
+		ts->support_hw_poweroff = false;
 
-	TPD_ERR("%s ts->support_hw_poweroff =%d\n",__func__,ts->support_hw_poweroff);
+	TPD_ERR("%s ts->support_hw_poweroff =%d\n", __func__, ts->support_hw_poweroff);
 
 	ts->enable2v8_gpio = of_get_named_gpio(np, "synaptics,enable2v8-gpio", 0);
-	if( ts->enable2v8_gpio < 0 ){
+
+	if (ts->enable2v8_gpio < 0) {
 		TPD_DEBUG("ts->enable2v8_gpio not specified\n");
 	}
 
 	rc = of_property_read_u32(np, "synaptics,max-num-support", &ts->max_num);
-	if(rc){
+
+	if (rc) {
 		TPD_DEBUG("ts->max_num not specified\n");
 		ts->max_num = 10;
 	}
 
 	rc = of_property_read_u32_array(np, "synaptics,button-map", button_map, 3);
-	if(rc){
+
+	if (rc) {
 		TPD_DEBUG("button-map not specified\n");
 		//button_map[0] = 180;
 		//button_map[1] = 180;
 		//button_map[2] = 2021;
 	}
+
 	TPD_DEBUG("synaptics:button map readed is %d %d %d\n", button_map[0], button_map[1], button_map[2]);
 
-	rc = of_property_read_u32_array(np, "synaptics,tx-rx-num", tx_rx_num,2);
-	if(rc){
+	rc = of_property_read_u32_array(np, "synaptics,tx-rx-num", tx_rx_num, 2);
+
+	if (rc) {
 		TPD_ERR("button-map not specified\n");
 		TX_NUM =  30;
 		RX_NUM =  17;
-	}else{
+	} else {
 		TX_NUM =  tx_rx_num[0];
 		RX_NUM =  tx_rx_num[1];
 	}
-	TPD_ERR("synaptics,tx-rx-num is %d %d \n", TX_NUM,RX_NUM);
+
+	TPD_ERR("synaptics,tx-rx-num is %d %d \n", TX_NUM, RX_NUM);
 
 	rc = of_property_read_u32_array(np, "synaptics,display-coords", temp_array, 2);
-	if(rc){
+
+	if (rc) {
 		TPD_ERR("lcd size not specified\n");
 		LCD_WIDTH = 1080;
 		LCD_HEIGHT = 1920;
-	}else{
+	} else {
 		LCD_WIDTH = temp_array[0];
 		LCD_HEIGHT = temp_array[1];
 	}
+
 	rc = of_property_read_u32_array(np, "synaptics,panel-coords", temp_array, 2);
-	if(rc){
+
+	if (rc) {
 		ts->max_x = 1080;
 		ts->max_y = 1920;
-	}else{
+	} else {
 		ts->max_x = temp_array[0];
 		ts->max_y = temp_array[1];
 	}
+
 	TPDTM_DMESG("synaptic:ts->irq_gpio:%d irq_flags:%u max_num %d\n"\
-        ,ts->irq_gpio, ts->irq_flags, ts->max_num);
+	            , ts->irq_gpio, ts->irq_flags, ts->max_num);
 
 	/***********power regulator_get****************/
 	ts->vdd_2v8 = regulator_get(&ts->client->dev, "vdd_2v8");
-	if( IS_ERR(ts->vdd_2v8) ){
+
+	if (IS_ERR(ts->vdd_2v8)) {
 		rc = PTR_ERR(ts->vdd_2v8);
 		TPD_DEBUG("Regulator get failed vdd rc=%d\n", rc);
 	}
-	rc = of_property_read_u32(np,"synaptics,avdd-current", &current_supply);
+
+	rc = of_property_read_u32(np, "synaptics,avdd-current", &current_supply);
+
 	if (rc < 0) {
-		TPD_ERR("%s: Failed to get regulator vdd current\n",__func__);
+		TPD_ERR("%s: Failed to get regulator vdd current\n", __func__);
 
 	}
+
 	ts->regulator_vdd_current = current_supply;
 
-	rc = regulator_set_load(ts->vdd_2v8,ts->regulator_vdd_current);
+	rc = regulator_set_load(ts->vdd_2v8, ts->regulator_vdd_current);
+
 	if (rc < 0) {
-		TPD_ERR("%s: Failed to set regulator current vdd\n",__func__);
+		TPD_ERR("%s: Failed to set regulator current vdd\n", __func__);
 	}
 
 
 	rc = of_property_read_u32_array(np, "synaptics,avdd-voltage", voltage_supply, 2);
+
 	if (rc < 0) {
-		TPD_ERR("%s: Failed to get regulator vdd voltage\n",__func__);
+		TPD_ERR("%s: Failed to get regulator vdd voltage\n", __func__);
 	}
+
 	ts->regulator_vdd_vmin = voltage_supply[0];
 	ts->regulator_vdd_vmax = voltage_supply[1];
 
-	rc = regulator_set_voltage(ts->vdd_2v8,ts->regulator_vdd_vmin,ts->regulator_vdd_vmax);
+	rc = regulator_set_voltage(ts->vdd_2v8, ts->regulator_vdd_vmin, ts->regulator_vdd_vmax);
+
 	if (rc < 0) {
-		TPD_ERR("%s:00Failed to set regulator voltage vdd\n",__func__);
+		TPD_ERR("%s:00Failed to set regulator voltage vdd\n", __func__);
 	}
 
 	ts->vcc_i2c_1v8 = regulator_get(&ts->client->dev, "vcc_i2c_1v8");
-	if( IS_ERR(ts->vcc_i2c_1v8) ){
+
+	if (IS_ERR(ts->vcc_i2c_1v8)) {
 		rc = PTR_ERR(ts->vcc_i2c_1v8);
 		TPD_DEBUG("Regulator get failed vcc_i2c rc=%d\n", rc);
 	}
 
-	rc = of_property_read_u32(np,"synaptics,vdd-current", &current_supply);
+	rc = of_property_read_u32(np, "synaptics,vdd-current", &current_supply);
+
 	if (rc < 0) {
-		TPD_ERR("%s: Failed to get regulator vdd current\n",__func__);
+		TPD_ERR("%s: Failed to get regulator vdd current\n", __func__);
 	}
+
 	ts->regulator_vdd_current = current_supply;
 
-	rc = regulator_set_load(ts->vcc_i2c_1v8,ts->regulator_vdd_current);
+	rc = regulator_set_load(ts->vcc_i2c_1v8, ts->regulator_vdd_current);
+
 	if (rc < 0) {
-		TPD_ERR("%s: Failed to set regulator current vdd\n",__func__);
+		TPD_ERR("%s: Failed to set regulator current vdd\n", __func__);
 	}
 
 
 	rc = of_property_read_u32_array(np, "synaptics,vdd-voltage", voltage_supply, 2);
+
 	if (rc < 0) {
-		TPD_ERR("%s: Failed to get regulator vdd voltage\n",__func__);
+		TPD_ERR("%s: Failed to get regulator vdd voltage\n", __func__);
 	}
+
 	ts->regulator_vdd_vmin = voltage_supply[0];
 	ts->regulator_vdd_vmax = voltage_supply[1];
 
-	rc = regulator_set_voltage(ts->vcc_i2c_1v8,ts->regulator_vdd_vmin,ts->regulator_vdd_vmax);
+	rc = regulator_set_voltage(ts->vcc_i2c_1v8, ts->regulator_vdd_vmin, ts->regulator_vdd_vmax);
+
 	if (rc < 0) {
-		TPD_ERR("%s:00Failed to set regulator voltage vdd\n",__func__);
+		TPD_ERR("%s:00Failed to set regulator voltage vdd\n", __func__);
 	}
 
 
 
-	if( ts->reset_gpio > 0){
-		if( gpio_is_valid(ts->reset_gpio) ){
+	if (ts->reset_gpio > 0) {
+		if (gpio_is_valid(ts->reset_gpio)) {
 			rc = gpio_request(ts->reset_gpio, "tp-s3320-reset");
-			if(rc){
+
+			if (rc) {
 				TPD_ERR("unable to request reset_gpio [%d]\n", ts->reset_gpio);
 			}
+
 			gpio_direction_output(ts->reset_gpio, 0);
 		}
 	}
-	if( ts->v1p8_gpio > 0){
-		if( gpio_is_valid(ts->v1p8_gpio) ){
+
+	if (ts->v1p8_gpio > 0) {
+		if (gpio_is_valid(ts->v1p8_gpio)) {
 			rc = gpio_request(ts->v1p8_gpio, "tp-s3320-1v8");
-			if(rc){
+
+			if (rc) {
 				TPD_ERR("unable to request v1p8_gpio [%d]\n", ts->v1p8_gpio);
 			}
 		}
 	}
 
-	if( ts->enable2v8_gpio > 0){
-		if( gpio_is_valid(ts->enable2v8_gpio) ){
+	if (ts->enable2v8_gpio > 0) {
+		if (gpio_is_valid(ts->enable2v8_gpio)) {
 			rc = gpio_request(ts->enable2v8_gpio, "rmi4-enable2v8-gpio");
-			if(rc)
+
+			if (rc)
 				TPD_ERR("unable to request enable2v8_gpio [%d]\n", ts->enable2v8_gpio);
 
 		}
@@ -4174,27 +4391,31 @@ static int synaptics_dsx_pinctrl_init(struct synaptics_ts_data *ts)
 
 	/* Get pinctrl if target uses pinctrl */
 	ts->pinctrl = devm_pinctrl_get((ts->dev));
+
 	if (IS_ERR_OR_NULL(ts->pinctrl)) {
 		retval = PTR_ERR(ts->pinctrl);
-        TPD_ERR("%s pinctrl error!\n",__func__);
+		TPD_ERR("%s pinctrl error!\n", __func__);
 		goto err_pinctrl_get;
 	}
 
 	ts->pinctrl_state_active
-		= pinctrl_lookup_state(ts->pinctrl, "pmx_ts_active");
+	    = pinctrl_lookup_state(ts->pinctrl, "pmx_ts_active");
+
 	if (IS_ERR_OR_NULL(ts->pinctrl_state_active)) {
 		retval = PTR_ERR(ts->pinctrl_state_active);
-        TPD_ERR("%s pinctrl state active error!\n",__func__);
+		TPD_ERR("%s pinctrl state active error!\n", __func__);
 		goto err_pinctrl_lookup;
 	}
 
 	ts->pinctrl_state_suspend
-		= pinctrl_lookup_state(ts->pinctrl, "pmx_ts_suspend");
+	    = pinctrl_lookup_state(ts->pinctrl, "pmx_ts_suspend");
+
 	if (IS_ERR_OR_NULL(ts->pinctrl_state_suspend)) {
 		retval = PTR_ERR(ts->pinctrl_state_suspend);
-        TPD_ERR("%s pinctrl state suspend error!\n",__func__);
+		TPD_ERR("%s pinctrl state suspend error!\n", __func__);
 		goto err_pinctrl_lookup;
 	}
+
 	return 0;
 
 err_pinctrl_lookup:
@@ -4210,50 +4431,54 @@ err_pinctrl_get:
 #define VK_WIDTH    170
 #define VK_HIGHT    200
 static ssize_t vk_syna_show(struct kobject *kobj,
-        struct kobj_attribute *attr, char *buf)
+                            struct kobj_attribute *attr, char *buf)
 {
-	int len ;
+	int len;
 
 	len =  sprintf(buf,
-	    __stringify(EV_KEY) ":" __stringify(KEY_APPSELECT)  ":%d:%d:%d:%d"
-	    ":" __stringify(EV_KEY) ":" __stringify(KEY_HOMEPAGE)  ":%d:%d:%d:%d"
-	    ":" __stringify(EV_KEY) ":" __stringify(KEY_BACK)  ":%d:%d:%d:%d" "\n",
-	    VK_KEY_X,   VK_CENTER_Y, VK_WIDTH, VK_HIGHT,
-	    VK_KEY_X*3, VK_CENTER_Y, VK_WIDTH, VK_HIGHT,
-	    VK_KEY_X*5, VK_CENTER_Y, VK_WIDTH, VK_HIGHT);
-
-	return len ;
+	               __stringify(EV_KEY) ":" __stringify(KEY_APPSELECT)  ":%d:%d:%d:%d"
+	               ":" __stringify(EV_KEY) ":" __stringify(KEY_HOMEPAGE)  ":%d:%d:%d:%d"
+	               ":" __stringify(EV_KEY) ":" __stringify(KEY_BACK)  ":%d:%d:%d:%d" "\n",
+	               VK_KEY_X,   VK_CENTER_Y, VK_WIDTH, VK_HIGHT,
+	               VK_KEY_X * 3, VK_CENTER_Y, VK_WIDTH, VK_HIGHT,
+	               VK_KEY_X * 5, VK_CENTER_Y, VK_WIDTH, VK_HIGHT);
+
+	return len;
 }
 
 static struct kobj_attribute vk_syna_attr = {
-    .attr = {
-        .name = "virtualkeys."TPD_DEVICE,
-        .mode = S_IRUGO,
-    },
-    .show = &vk_syna_show,
+	.attr = {
+		.name = "virtualkeys."TPD_DEVICE,
+		.mode = S_IRUGO,
+	},
+	.show = &vk_syna_show,
 };
 
 static struct attribute *syna_properties_attrs[] = {
-    &vk_syna_attr.attr,
-    NULL
+	&vk_syna_attr.attr,
+	NULL
 };
 
 static struct attribute_group syna_properties_attr_group = {
-    .attrs = syna_properties_attrs,
+	.attrs = syna_properties_attrs,
 };
-static int synaptics_ts_init_virtual_key(struct synaptics_ts_data *ts )
+
+static int synaptics_ts_init_virtual_key(struct synaptics_ts_data *ts)
 {
 	int ret = 0;
 
 	/* virtual keys */
-	if(ts->properties_kobj)
-		return 0 ;
+	if (ts->properties_kobj)
+		return 0;
+
 	ts->properties_kobj = kobject_create_and_add("board_properties", NULL);
+
 	if (ts->properties_kobj)
 		ret = sysfs_create_group(ts->properties_kobj, &syna_properties_attr_group);
 
 	if (!ts->properties_kobj || ret)
 		printk("%s: failed to create board_properties\n", __func__);
+
 	/* virtual keys */
 	return ret;
 }
@@ -4270,10 +4495,11 @@ static int synaptics_ts_probe(struct i2c_client *client, const struct i2c_device
 	uint32_t CURRENT_FIRMWARE_ID = 0;
 	uint32_t bootloader_mode;
 
-	TPD_ERR("%s  is called\n",__func__);
+	TPD_ERR("%s  is called\n", __func__);
 
 	ts = kzalloc(sizeof(struct synaptics_ts_data), GFP_KERNEL);
-	if( ts == NULL ) {
+
+	if (ts == NULL) {
 		ret = -ENOMEM;
 		goto err_alloc_data_failed;
 	}
@@ -4290,37 +4516,43 @@ static int synaptics_ts_probe(struct i2c_client *client, const struct i2c_device
 
 	/***power_init*****/
 	ret = tpd_power(ts, 1);
-	if( ret < 0 )
+
+	if (ret < 0)
 		TPD_ERR("regulator_enable is called\n");
+
 	ret = synaptics_dsx_pinctrl_init(ts);
+
 	if (!ret && ts->pinctrl) {
 		ret = pinctrl_select_state(ts->pinctrl,
-                ts->pinctrl_state_active);
+		                           ts->pinctrl_state_active);
 	}
 
 	msleep(100);//after power on tp need sometime from bootloader to ui mode
 	mutex_init(&ts->mutex);
 	mutex_init(&ts->mutexreport);
-	atomic_set(&ts->irq_enable,0);
+	atomic_set(&ts->irq_enable, 0);
 
 	ts->is_suspended = 0;
-	atomic_set(&ts->is_stop,0);
+	atomic_set(&ts->is_stop, 0);
 	spin_lock_init(&ts->lock);
+
 	/*****power_end*********/
-	if( !i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA) ){
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
 		TPD_ERR("%s [ERR]need I2C_FUNC_I2C\n", __func__);
 		ret = -ENODEV;
 		goto err_check_functionality_failed;
 	}
 
 	ret = synaptics_rmi4_i2c_read_byte(client, 0x13);
-	if( ret < 0 ) {
+
+	if (ret < 0) {
 		ret = synaptics_rmi4_i2c_read_byte(client, 0x13);
-		if( ret < 0 ) {
-		#ifdef SUPPORT_VIRTUAL_KEY
-                        virtual_key_enable = 0;//if touch is no valid report key
-                #endif
-                        TPD_ERR("tp is no exist!\n");
+
+		if (ret < 0) {
+#ifdef SUPPORT_VIRTUAL_KEY
+			virtual_key_enable = 0;//if touch is no valid report key
+#endif
+			TPD_ERR("tp is no exist!\n");
 			goto err_check_functionality_failed;
 		}
 	}
@@ -4330,85 +4562,99 @@ static int synaptics_ts_probe(struct i2c_client *client, const struct i2c_device
 	synaptics_read_register_map(ts);
 	bootloader_mode = synaptics_rmi4_i2c_read_byte(ts->client, F01_RMI_DATA_BASE);
 
-	bootloader_mode = bootloader_mode&0x40;
+	bootloader_mode = bootloader_mode & 0x40;
 	TPD_ERR("before fw update bootloader_mode[0x%x]\n", bootloader_mode);
 
 	synaptics_rmi4_i2c_read_block(ts->client, F34_FLASH_CTRL00, 4, buf);
-	CURRENT_FIRMWARE_ID = (buf[0]<<24) | (buf[1]<<16) | (buf[2]<<8) | buf[3];
+	CURRENT_FIRMWARE_ID = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
 	TPD_ERR("CURRENT_FIRMWARE_ID = 0x%x\n", CURRENT_FIRMWARE_ID);
 	TP_FW = CURRENT_FIRMWARE_ID;
-	sprintf(ts->fw_id,"0x%x",TP_FW);
+	sprintf(ts->fw_id, "0x%x", TP_FW);
 
 	memset(ts->fw_name, 0, TP_FW_NAME_MAX_LEN);
 	memset(ts->test_limit_name, 0, TP_FW_NAME_MAX_LEN);
 
 	//sprintf(ts->manu_name, "TP_SYNAPTICS");
-	synaptics_rmi4_i2c_read_block(ts->client, F01_RMI_QUERY11,\
-        sizeof(ts->manu_name), ts->manu_name);
-	if (!strncmp(ts->manu_name,"S3718",5)){
-		strcpy(ts->fw_name,"tp/fw_synaptics_15801b.img");
+	synaptics_rmi4_i2c_read_block(ts->client, F01_RMI_QUERY11, \
+	                              sizeof(ts->manu_name), ts->manu_name);
+
+	if (!strncmp(ts->manu_name, "S3718", 5)) {
+		strcpy(ts->fw_name, "tp/fw_synaptics_15801b.img");
 		version_is_s3508 = 0;
-	}else{
-		strcpy(ts->fw_name,"tp/fw_synaptics_16859.img");
+	} else {
+		strcpy(ts->fw_name, "tp/fw_synaptics_16859.img");
 		version_is_s3508 = 1;
 	}
 
-	strcpy(ts->test_limit_name,"tp/14049/14049_Limit_jdi.img");
-	TPD_DEBUG("synatpitcs_fw: fw_name = %s,ts->manu_name:%s \n",ts->fw_name,ts->manu_name);
+	strcpy(ts->test_limit_name, "tp/14049/14049_Limit_jdi.img");
+	TPD_DEBUG("synatpitcs_fw: fw_name = %s,ts->manu_name:%s \n", ts->fw_name, ts->manu_name);
 
 	push_component_info(TOUCH_KEY, ts->fw_id, ts->manu_name);
 	push_component_info(TP, ts->fw_id, ts->manu_name);
 
 	synaptics_wq = create_singlethread_workqueue("synaptics_wq");
-	if( !synaptics_wq ){
+
+	if (!synaptics_wq) {
 		ret = -ENOMEM;
 		goto exit_createworkqueue_failed;
 	}
-	INIT_DELAYED_WORK(&ts->speed_up_work,speedup_synaptics_resume);
 
+	INIT_DELAYED_WORK(&ts->speed_up_work, speedup_synaptics_resume);
 
-	memset(baseline,0,sizeof(baseline));
+
+	memset(baseline, 0, sizeof(baseline));
 	get_base_report = create_singlethread_workqueue("get_base_report");
-	if( !get_base_report ){
+
+	if (!get_base_report) {
 		ret = -ENOMEM;
 		goto exit_createworkqueue_failed;
 	}
-	INIT_DELAYED_WORK(&ts->base_work,tp_baseline_get_work);
+
+	INIT_DELAYED_WORK(&ts->base_work, tp_baseline_get_work);
 
 	ret = synaptics_init_panel(ts); /* will also switch back to page 0x04 */
+
 	if (ret < 0) {
 		TPD_ERR("synaptics_init_panel failed\n");
 	}
 
 	//Detect whether TP FW is error, max_x,max_y may be incoorect while it has been damaged!
 	ret = synaptics_fw_check(ts);
-	if(ret < 0 ) {
+
+	if (ret < 0) {
 		force_update = 1;
 		TPD_ERR("This FW need to be updated!\n");
 	} else {
 		force_update = 0;
 	}
+
 	/*disable interrupt*/
 	ret = synaptics_enable_interrupt(ts, 0);
-	if( ret < 0 ) {
+
+	if (ret < 0) {
 		TPD_ERR(" synaptics_ts_probe: disable interrupt failed\n");
 	}
+
 	ret = synaptics_soft_reset(ts);
-	if (ret < 0){
-		TPD_ERR("%s faile to reset device\n",__func__);
+
+	if (ret < 0) {
+		TPD_ERR("%s faile to reset device\n", __func__);
 	}
+
 	ret = synaptics_input_init(ts);
-	if(ret < 0) {
+
+	if (ret < 0) {
 		TPD_ERR("synaptics_input_init failed!\n");
 	}
+
 #if defined(CONFIG_FB)
 	ts->fb_notif.notifier_call = fb_notifier_callback;
 	ret = fb_register_client(&ts->fb_notif);
-	if(ret)
-		TPD_ERR("Unable to register fb_notifier: %d\n", ret);
-#endif
 
+	if (ret)
+		TPD_ERR("Unable to register fb_notifier: %d\n", ret);
 
+#endif
 
 #ifndef TPD_USE_EINT
 	hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
@@ -4417,64 +4663,80 @@ static int synaptics_ts_probe(struct i2c_client *client, const struct i2c_device
 #endif
 
 #ifdef TPD_USE_EINT
+
 	/****************
 	  shoud set the irq GPIO
 	 *******************/
 	if (gpio_is_valid(ts->irq_gpio)) {
-        /* configure touchscreen irq gpio */
-        ret = gpio_request(ts->irq_gpio,"tp-s3320-irq");
-        if (ret) {
-            TPD_ERR("unable to request gpio [%d]\n",ts->irq_gpio);
-        }
-        ret = gpio_direction_input(ts->irq_gpio);
-        msleep(50);
-        ts->irq = gpio_to_irq(ts->irq_gpio);
+		/* configure touchscreen irq gpio */
+		ret = gpio_request(ts->irq_gpio, "tp-s3320-irq");
+
+		if (ret) {
+			TPD_ERR("unable to request gpio [%d]\n", ts->irq_gpio);
+		}
+
+		ret = gpio_direction_input(ts->irq_gpio);
+		msleep(50);
+		ts->irq = gpio_to_irq(ts->irq_gpio);
 	}
-	TPD_ERR("synaptic:ts->irq is %d\n",ts->irq);
+
+	TPD_ERR("synaptic:ts->irq is %d\n", ts->irq);
 
 	ret = request_threaded_irq(ts->irq, NULL,
-			synaptics_irq_thread_fn,
-			ts->irq_flags | IRQF_ONESHOT,
-			TPD_DEVICE, ts);
-	if(ret < 0)
-		TPD_ERR("%s request_threaded_irq ret is %d\n",__func__,ret);
+	                           synaptics_irq_thread_fn,
+	                           ts->irq_flags | IRQF_ONESHOT,
+	                           TPD_DEVICE, ts);
+
+	if (ret < 0)
+		TPD_ERR("%s request_threaded_irq ret is %d\n", __func__, ret);
+
 	msleep(5);
 	ret = synaptics_enable_interrupt(ts, 1);
-	if(ret < 0)
-		TPD_ERR("%s enable interrupt error ret=%d\n",__func__,ret);
+
+	if (ret < 0)
+		TPD_ERR("%s enable interrupt error ret=%d\n", __func__, ret);
+
 #endif
 
 	if (device_create_file(&client->dev, &dev_attr_test_limit)) {
 		TPDTM_DMESG("driver_create_file failt\n");
 		goto exit_init_failed;
 	}
+
 	TPD_DEBUG("synaptics_ts_probe: going to create files--tp_fw_update\n");
+
 	if (device_create_file(&client->dev, &dev_attr_tp_fw_update)) {
 		TPDTM_DMESG("driver_create_file failt\n");
 		goto exit_init_failed;
 	}
-	if( driver_create_file(&tpd_i2c_driver.driver, &driver_attr_tp_debug_log)) {
+
+	if (driver_create_file(&tpd_i2c_driver.driver, &driver_attr_tp_debug_log)) {
 		TPDTM_DMESG("driver_create_file failt\n");
 		goto exit_init_failed;
 	}
+
 	if (driver_create_file(&tpd_i2c_driver.driver, &driver_attr_tp_baseline_image_with_cbc)) {
 		TPDTM_DMESG("driver_create_file failt\n");
 		goto exit_init_failed;
 	}
-	if( driver_create_file(&tpd_i2c_driver.driver, &driver_attr_tp_baseline_image)) {
+
+	if (driver_create_file(&tpd_i2c_driver.driver, &driver_attr_tp_baseline_image)) {
 		TPDTM_DMESG("driver_create_file failt\n");
 		goto exit_init_failed;
 	}
-	if( driver_create_file(&tpd_i2c_driver.driver, &driver_attr_tp_delta_image)) {
+
+	if (driver_create_file(&tpd_i2c_driver.driver, &driver_attr_tp_delta_image)) {
 		TPDTM_DMESG("driver_create_file failt\n");
 		goto exit_init_failed;
 	}
+
 #ifdef SUPPORT_VIRTUAL_KEY
 	synaptics_ts_init_virtual_key(ts);
 #endif
 #ifdef CONFIG_SYNAPTIC_RED
 	premote_data = remote_alloc_panel_data();
-	if(premote_data) {
+
+	if (premote_data) {
 		premote_data->client 		= client;
 		premote_data->input_dev		= ts->input_dev;
 		premote_data->pmutex		= &ts->mutex;
@@ -4484,13 +4746,14 @@ static int synaptics_ts_probe(struct i2c_client *client, const struct i2c_device
 		register_remote_device(premote_data);
 
 	}
+
 #endif
 	init_synaptics_proc();
 	TPDTM_DMESG("synaptics_ts_probe 3203: normal end\n");
 	return 0;
 
 exit_init_failed:
-	free_irq(client->irq,ts);
+	free_irq(client->irq, ts);
 exit_createworkqueue_failed:
 	destroy_workqueue(synaptics_wq);
 	synaptics_wq = NULL;
@@ -4502,7 +4765,7 @@ exit_createworkqueue_failed:
 err_check_functionality_failed:
 	tpd_power(ts, 0);
 err_alloc_data_failed:
-	tpd_i2c_driver.driver.pm=NULL;
+	tpd_i2c_driver.driver.pm = NULL;
 	kfree(ts);
 	ts = NULL;
 	ts_g = NULL;
@@ -4515,56 +4778,65 @@ static int synaptics_ts_remove(struct i2c_client *client)
 	int attr_count;
 	struct synaptics_ts_data *ts = i2c_get_clientdata(client);
 
-	TPD_ERR("%s is called\n",__func__);
+	TPD_ERR("%s is called\n", __func__);
 #ifdef CONFIG_SYNAPTIC_RED
 	unregister_remote_device();
 #endif
 
 #if defined(CONFIG_FB)
-	if( fb_unregister_client(&ts->fb_notif) )
+
+	if (fb_unregister_client(&ts->fb_notif))
 		dev_err(&client->dev, "Error occurred while unregistering fb_notifier.\n");
+
 #endif
 
 #ifndef TPD_USE_EINT
 	hrtimer_cancel(&ts->timer);
 #endif
 
-	for(attr_count = 0; attr_count < ARRAY_SIZE(attrs_oem); attr_count++){
+	for (attr_count = 0; attr_count < ARRAY_SIZE(attrs_oem); attr_count++) {
 		sysfs_remove_file(&ts->input_dev->dev.kobj, &attrs_oem[attr_count].attr);
 	}
+
 	input_unregister_device(ts->input_dev);
 	input_free_device(ts->input_dev);
 	kfree(ts);
-	tpd_power(ts,0);
+	tpd_power(ts, 0);
 	return 0;
 }
 
 static int synaptics_ts_suspend(struct device *dev)
 {
-	int ret,i;
+	int ret, i;
 	struct synaptics_ts_data *ts = dev_get_drvdata(dev);
 
-	if(ts->input_dev == NULL) {
+	if (ts->input_dev == NULL) {
 		ret = -ENOMEM;
 		TPD_ERR("input_dev  registration is not complete\n");
 		return -1;
 	}
+
 	TPD_DEBUG("%s enter\n", __func__);
 
-	if (ts->pre_btn_state & 0x01){//if press key and suspend release key
-		ts->pre_btn_state &= 0x02;//clear bit0
-		input_report_key(ts->input_dev, OEM_KEY_BACK, 0);
+	// release left key if pressed
+	if (ts->pre_btn_state & BUTTON_LEFT) {
+		ts->pre_btn_state &= ~BUTTON_LEFT;
+		input_report_key(ts->input_dev, ts->key_swap ? KEY_BUTTON_RIGHT : KEY_BUTTON_LEFT, 0);
 		input_sync(ts->input_dev);
-	}else if (ts->pre_btn_state & 0x02){
-		ts->pre_btn_state &= 0x01;//clear bit1
-		input_report_key(ts->input_dev, OEM_KEY_APPSELECT, 0);
+	}
+
+	// release left right if pressed
+	if (ts->pre_btn_state & BUTTON_RIGHT) {
+		ts->pre_btn_state &= ~BUTTON_RIGHT;
+		input_report_key(ts->input_dev, ts->key_swap ? KEY_BUTTON_LEFT : KEY_BUTTON_RIGHT, 0);
 		input_sync(ts->input_dev);
 	}
-	for (i = 0; i < ts->max_num; i++)
-	{
+
+	for (i = 0; i < ts->max_num; i++) {
 		input_mt_slot(ts->input_dev, i);
 		input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 0);
 	}
+
 	input_report_key(ts->input_dev, BTN_TOOL_FINGER, 0);
 	input_sync(ts->input_dev);
 
@@ -4573,21 +4845,24 @@ static int synaptics_ts_suspend(struct device *dev)
 #endif
 
 #ifdef SUPPORT_GESTURE
-	if( ts->gesture_enable ){
-		atomic_set(&ts->is_stop,0);
-		if (mutex_trylock(&ts->mutex)){
+
+	if (ts->gestures_enable != 0) {
+		atomic_set(&ts->is_stop, 0);
+
+		if (mutex_trylock(&ts->mutex)) {
 			touch_enable(ts);
 			synaptics_enable_interrupt_for_gesture(ts, 1);
 			mutex_unlock(&ts->mutex);
 			TPD_ERR("enter gesture mode\n");
 		}
-	}
-	else{
+	} else {
 		ret = synaptics_mode_change(0x01);//when gesture disable TP sleep eary
-		if (ret < 0){
-			TPD_ERR("%s line%d ERROR %d!\n",__func__, __LINE__, ret);
+
+		if (ret < 0) {
+			TPD_ERR("%s line%d ERROR %d!\n", __func__, __LINE__, ret);
 		}
 	}
+
 #endif
 	TPD_DEBUG("%s normal end\n", __func__);
 	return 0;
@@ -4600,16 +4875,20 @@ static void speedup_synaptics_resume(struct work_struct *work)
 
 //#ifdef SUPPORT_SLEEP_POWEROFF
 	TPD_DEBUG("%s enter!\n", __func__);
-    if (ts->support_hw_poweroff){
-        if(0 == ts->gesture_enable){
+
+	if (ts->support_hw_poweroff) {
+		if (ts->gestures_enable == 0) {
 			if (ts->pinctrl) {
 				ret = pinctrl_select_state(ts->pinctrl, ts->pinctrl_state_active);
 			}
-            ret = tpd_power(ts,1);
-            if (ret < 0)
-                TPD_ERR("%s power on err\n",__func__);
-        }
-    }
+
+			ret = tpd_power(ts, 1);
+
+			if (ret < 0)
+				TPD_ERR("%s power on err\n", __func__);
+		}
+	}
+
 	TPD_DEBUG("%s end!\n", __func__);
 //#endif
 }
@@ -4622,27 +4901,28 @@ static int synaptics_ts_resume(struct device *dev)
 
 	TPD_DEBUG("%s enter!\n", __func__);
 
-	if(ts->loading_fw) {
-		TPD_ERR("%s FW is updating break!\n",__func__);
+	if (ts->loading_fw) {
+		TPD_ERR("%s FW is updating break!\n", __func__);
 		return -1;
 	}
 
-	if(ts->input_dev == NULL) {
+	if (ts->input_dev == NULL) {
 		ret = -ENOMEM;
 		TPD_ERR("input_dev  registration is not complete\n");
 		goto ERR_RESUME;
 	}
-	for (i = 0; i < ts->max_num; i++)
-	{
+
+	for (i = 0; i < ts->max_num; i++) {
 		input_mt_slot(ts->input_dev, i);
 		input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 1);
 		input_mt_slot(ts->input_dev, i);
 		input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 0);
 	}
+
 	input_report_key(ts->input_dev, BTN_TOOL_FINGER, 0);
 	input_sync(ts->input_dev);
 
-    //touch_enable(ts);
+	//touch_enable(ts);
 
 	TPD_DEBUG("%s:normal end!\n", __func__);
 ERR_RESUME:
@@ -4655,24 +4935,30 @@ static int synaptics_i2c_suspend(struct device *dev)
 	struct synaptics_ts_data *ts = dev_get_drvdata(dev);
 
 	TPD_DEBUG("%s: is called\n", __func__);
-	if (ts->gesture_enable == 1){
+
+	if (ts->gestures_enable != 0) {
 		/*enable gpio wake system through intterrupt*/
 		enable_irq_wake(ts->irq);
 	}
+
 //#ifdef SUPPORT_SLEEP_POWEROFF
-	if(ts->loading_fw) {
+	if (ts->loading_fw) {
 		TPD_ERR("FW is updating while suspending");
 		return -1;
 	}
-    if(ts->support_hw_poweroff && (ts->gesture_enable == 0)){
-	    ret = tpd_power(ts,0);
-	    if (ret < 0)
-	        TPD_ERR("%s power off err\n",__func__);
-		if (ts->pinctrl){
+
+	if (ts->support_hw_poweroff && (ts->gestures_enable == 0)) {
+		ret = tpd_power(ts, 0);
+
+		if (ret < 0)
+			TPD_ERR("%s power off err\n", __func__);
+
+		if (ts->pinctrl) {
 			ret = pinctrl_select_state(ts->pinctrl,
-					ts->pinctrl_state_suspend);
+			                           ts->pinctrl_state_suspend);
 		}
 	}
+
 //#endif
 	return 0;
 }
@@ -4682,11 +4968,13 @@ static int synaptics_i2c_resume(struct device *dev)
 	struct synaptics_ts_data *ts = dev_get_drvdata(dev);
 
 	TPD_DEBUG("%s is called\n", __func__);
-    queue_delayed_work(synaptics_wq,&ts->speed_up_work, msecs_to_jiffies(1));
-	if (ts->gesture_enable == 1){
+	queue_delayed_work(synaptics_wq, &ts->speed_up_work, msecs_to_jiffies(1));
+
+	if (ts->gestures_enable != 0) {
 		/*disable gpio wake system through intterrupt*/
 		disable_irq_wake(ts->irq);
 	}
+
 	return 0;
 }
 
@@ -4697,16 +4985,21 @@ static int synaptics_mode_change(int mode)
 	tmp_mode = i2c_smbus_read_byte_data(ts_g->client, F01_RMI_CTRL00);
 	tmp_mode = tmp_mode & 0xF8;//bit0-bit2(mode)
 	tmp_mode = tmp_mode | mode;
+
 	if (ts_g->changer_connet)
 		tmp_mode = tmp_mode | 0x20;//set bit6(change status)
 	else
 		tmp_mode = tmp_mode & 0xDF;//clear bit6(change status)
-	TPD_DEBUG("%s: set TP to mode[0x%x]\n", __func__,tmp_mode);
+
+	TPD_DEBUG("%s: set TP to mode[0x%x]\n", __func__, tmp_mode);
 	ret = i2c_smbus_write_byte_data(ts_g->client, F01_RMI_CTRL00, tmp_mode);
-	if(ret<0)
-		TPD_ERR("%s: set dose mode[0x%x] err!!\n", __func__,tmp_mode);
+
+	if (ret < 0)
+		TPD_ERR("%s: set dose mode[0x%x] err!!\n", __func__, tmp_mode);
+
 	return ret;
 }
+
 #if defined(CONFIG_FB)
 static int fb_notifier_callback(struct notifier_block *self, unsigned long event, void *data)
 {
@@ -4715,39 +5008,40 @@ static int fb_notifier_callback(struct notifier_block *self, unsigned long event
 
 	struct synaptics_ts_data *ts = container_of(self, struct synaptics_ts_data, fb_notif);
 
-	if(FB_EARLY_EVENT_BLANK != event && FB_EVENT_BLANK != event)
-	return 0;
-	if((evdata) && (evdata->data) && (ts) && (ts->client))
-	{
+	if (FB_EARLY_EVENT_BLANK != event && FB_EVENT_BLANK != event)
+		return 0;
+
+	if ((evdata) && (evdata->data) && (ts) && (ts->client)) {
 		blank = evdata->data;
-		TPD_DEBUG("%s blank[%d],event[0x%lx]\n", __func__,*blank,event);
+		TPD_DEBUG("%s blank[%d],event[0x%lx]\n", __func__, *blank, event);
 
-		if((*blank == FB_BLANK_UNBLANK/* || *blank == FB_BLANK_VSYNC_SUSPEND || *blank == FB_BLANK_NORMAL*/)\
-            //&& (event == FB_EVENT_BLANK ))
-		 && (event == FB_EARLY_EVENT_BLANK ))
-		{
-			if (ts->is_suspended == 1)
-			{
+		if ((*blank == FB_BLANK_UNBLANK/* || *blank == FB_BLANK_VSYNC_SUSPEND || *blank == FB_BLANK_NORMAL*/)\
+		        //&& (event == FB_EVENT_BLANK ))
+		        && (event == FB_EARLY_EVENT_BLANK)) {
+			if (ts->is_suspended == 1) {
 				TPD_DEBUG("%s going TP resume start\n", __func__);
 				ts->is_suspended = 0;
-				queue_delayed_work(get_base_report, &ts->base_work,msecs_to_jiffies(80));
+				queue_delayed_work(get_base_report, &ts->base_work, msecs_to_jiffies(80));
 				synaptics_ts_resume(&ts->client->dev);
 				//atomic_set(&ts->is_stop,0);
 				TPD_DEBUG("%s going TP resume end\n", __func__);
 			}
-		}else if( *blank == FB_BLANK_POWERDOWN && (event == FB_EARLY_EVENT_BLANK )){
-			if (ts->is_suspended == 0){
+		} else if (*blank == FB_BLANK_POWERDOWN && (event == FB_EARLY_EVENT_BLANK)) {
+			if (ts->is_suspended == 0) {
 				TPD_DEBUG("%s : going TP suspend start\n", __func__);
 				ts->is_suspended = 1;
-				atomic_set(&ts->is_stop,1);
-					if(!(ts->gesture_enable)){
-						touch_disable(ts);
-					}
+				atomic_set(&ts->is_stop, 1);
+
+				if (ts->gestures_enable == 0) {
+					touch_disable(ts);
+				}
+
 				synaptics_ts_suspend(&ts->client->dev);
 				TPD_DEBUG("%s : going TP suspend end\n", __func__);
 			}
 		}
 	}
+
 	return 0;
 }
 #endif
@@ -4755,10 +5049,12 @@ static int fb_notifier_callback(struct notifier_block *self, unsigned long event
 static int __init tpd_driver_init(void)
 {
 	TPD_ERR("%s enter\n", __func__);
-	if( i2c_add_driver(&tpd_i2c_driver)!= 0 ){
+
+	if (i2c_add_driver(&tpd_i2c_driver) != 0) {
 		TPD_ERR("unable to add i2c driver.\n");
 		return -1;
 	}
+
 	return 0;
 }
 
@@ -4766,10 +5062,12 @@ static int __init tpd_driver_init(void)
 static void __exit tpd_driver_exit(void)
 {
 	i2c_del_driver(&tpd_i2c_driver);
-	if(synaptics_wq ){
+
+	if (synaptics_wq) {
 		destroy_workqueue(synaptics_wq);
 		synaptics_wq = NULL;
 	}
+
 	return;
 }
 
-- 
2.7.4

